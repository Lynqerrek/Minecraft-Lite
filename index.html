<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>MineLite — 2D Top-Down</title>
  <style>
    html,body{height:100%;margin:0;background:#0b1220;color:#ddd;font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;overflow:hidden}
    canvas{display:block}
    .hud{position:fixed;left:12px;top:12px;color:#fff;background:rgba(0,0,0,.28);padding:8px;border-radius:6px;font-size:13px;pointer-events:none}
    .title{font-weight:700;margin-bottom:6px}
    .hint{opacity:.9}
    .stamina{position:fixed;left:12px;bottom:12px;padding:6px;background:rgba(0,0,0,0.32);border-radius:8px;color:#fff;font-family:monospace;pointer-events:none}
  </style>
</head>
<body>
  <canvas id="game"></canvas>
  <div id="hud" class="hud">
    <div class="title">MineLite</div>
    <div><strong>Controls</strong></div>
    <div class="hint">WASD / Arrows — move</div>
    <div class="hint">Hold Shift — run (uses stamina)</div>
    <div class="hint">Mouse — aim</div>
    <div class="hint">Scroll — zoom (Ctrl+Scroll disabled)</div>
  </div>
  <div id="stamina" class="stamina">Stamina: <span id="staminaVal">100</span></div>

<script>
// MineLite — Scaling + stamina adjustments
// - UI (HUD & stamina) scales based on screen size and devicePixelRatio
// - Running allowance threshold lowered to 1 (instead of 4)
// - Stamina drains faster (higher drain rate) but allow running until stamina > 1

const TILE = 48;
const MAP_W = 640;
const MAP_H = 640;
const DPR = window.devicePixelRatio || 1;

const GRASS_VARIANTS = 4;
const TILE_GRASS_BASE = 0; // 0..3
const TILE_DIRT = GRASS_VARIANTS;    // 4
const TILE_WATER = GRASS_VARIANTS+1; // 5

const OBJ_NONE = 0, OBJ_ROCK = 1, OBJ_TREE = 2;
const BARRIER_THICKNESS = Math.max(10, Math.floor(Math.min(MAP_W, MAP_H) * 0.12)) * 2;

// Zoom config
const ZOOM_IN_MAX = 3.6;
const ZOOM_OUT_MIN = ZOOM_IN_MAX / 1.5;
const CAMERA_DEFAULT = (ZOOM_IN_MAX + ZOOM_OUT_MIN) / 2;

function makeSeededRandom(seed){ let s = seed>>>0; return function(){ s = (s + 0x6D2B79F5) | 0; let t = Math.imul(s ^ s>>>15, 1 | s); t = (t + Math.imul(t ^ t>>>7, 61 | t)) ^ t; return ((t ^ t>>>14) >>> 0) / 4294967296; } }
function smoothstep(a){ return a*a*(3-2*a); }
function valueNoise2D(x,y,seed){ const xf=Math.floor(x), yf=Math.floor(y); const rx=x-xf, ry=y-yf; const u=smoothstep(rx), v=smoothstep(ry); const r00 = makeSeededRandom(((xf*73856093) ^ (yf*19349663) ^ seed)>>>0)(); const r10 = makeSeededRandom((((xf+1)*73856093) ^ (yf*19349663) ^ seed)>>>0)(); const r01 = makeSeededRandom(((xf*73856093) ^ ((yf+1)*19349663) ^ seed)>>>0)(); const r11 = makeSeededRandom((((xf+1)*73856093) ^ ((yf+1)*19349663) ^ seed)>>>0)(); const xa = r00*(1-u) + r10*u; const xb = r01*(1-u) + r11*u; return xa*(1-v) + xb*v; }
function octaveNoise(x,y,seed,oct=4,scale=1){ let amp=1,freq=1,sum=0,tot=0; for(let i=0;i<oct;i++){ sum += valueNoise2D(x*freq/scale, y*freq/scale, seed + i*1000) * amp; tot += amp; amp *= 0.5; freq *= 2; } return sum/tot; }

const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
let canvasW=0, canvasH=0;
let uiScale = DPR; // will adjust on resize
function resizeCanvas(){ canvasW = Math.max(320, window.innerWidth); canvasH = Math.max(240, window.innerHeight); canvas.style.width = canvasW + 'px'; canvas.style.height = canvasH + 'px'; canvas.width = Math.floor(canvasW * DPR); canvas.height = Math.floor(canvasH * DPR); ctx.setTransform(DPR,0,0,DPR,0,0);
  // uiScale: scale HUD relative to 1920x1080 baseline, so 4k doubles sizes
  const baselineW = 1920, baselineH = 1080;
  const ratio = Math.min(canvasW / baselineW, canvasH / baselineH);
  uiScale = Math.max(1, ratio) * DPR;
  styleHUD(); }
window.addEventListener('resize', resizeCanvas); resizeCanvas();

// Prevent browser zoom via Ctrl + scroll and pinch gestures
window.addEventListener('wheel', function(e){ if(e.ctrlKey){ e.preventDefault(); } }, {passive:false});
window.addEventListener('gesturestart', e=>{ e.preventDefault(); }, {passive:false});

function styleHUD(){ const hud = document.getElementById('hud'); const st = document.getElementById('stamina'); if(hud){ hud.style.left = (12 * uiScale) + 'px'; hud.style.top = (12 * uiScale) + 'px'; hud.style.padding = (8 * uiScale) + 'px'; hud.style.fontSize = Math.max(12, 13 * uiScale) + 'px'; hud.style.borderRadius = (6 * uiScale) + 'px'; }
  if(st){ st.style.left = (12 * uiScale) + 'px'; st.style.bottom = (12 * uiScale) + 'px'; st.style.padding = (6 * uiScale) + 'px'; st.style.borderRadius = (8 * uiScale) + 'px'; st.style.fontSize = Math.max(12, 13 * uiScale) + 'px'; st.style.minWidth = (140 * uiScale) + 'px'; }}

// -----------------------------------------------------------------------------
class World {
  constructor(w,h){ this.w=w; this.h=h; this.tiles = new Uint8Array(w*h); this.objects = new Uint8Array(w*h); this.grassVariant = new Uint8Array(w*h); this.rockOffsetX = new Float32Array(w*h); this.rockOffsetY = new Float32Array(w*h); this.treeAnchor = new Uint8Array(w*h); this.seed = Math.floor(Math.random()*1e9); this.generate(); }
  idx(x,y){ return y*this.w + x; }
  inBounds(x,y){ return x>=0 && y>=0 && x<this.w && y<this.h; }
  getTile(x,y){ if(!this.inBounds(x,y)) return TILE_WATER; return this.tiles[this.idx(x,y)]; }
  getObject(x,y){ if(!this.inBounds(x,y)) return OBJ_NONE; return this.objects[this.idx(x,y)]; }
  setTile(x,y,v){ if(!this.inBounds(x,y)) return; this.tiles[this.idx(x,y)] = v; }
  setObject(x,y,v){ if(!this.inBounds(x,y)) return; this.objects[this.idx(x,y)] = v; }

  generate(){ const seed = this.seed; const biomeScale = 90; const localScale = 8; const biome = new Float32Array(this.w*this.h); for(let y=0;y<this.h;y++) for(let x=0;x<this.w;x++) biome[this.idx(x,y)] = octaveNoise(x,y,seed,5,biomeScale);
    const rnd = makeSeededRandom(seed+42);
    for(let y=0;y<this.h;y++){
      for(let x=0;x<this.w;x++){
        const i = this.idx(x,y); const b = biome[i];
        if(x < BARRIER_THICKNESS || y < BARRIER_THICKNESS || x > this.w-1-BARRIER_THICKNESS || y > this.h-1-BARRIER_THICKNESS){ this.tiles[i] = TILE_WATER; continue; }
        if(b < 0.35){ const local = octaveNoise(x,y,seed+2000,3,localScale); this.tiles[i] = (local < 0.5) ? TILE_WATER : TILE_GRASS_BASE + Math.floor(octaveNoise(x,y,seed+7000,2,4)*GRASS_VARIANTS); }
        else if(b < 0.67){ this.tiles[i] = TILE_GRASS_BASE + Math.floor(octaveNoise(x,y,seed+3000,3,6)*GRASS_VARIANTS); }
        else { const local = octaveNoise(x,y,seed+4000,3,6); this.tiles[i] = (local < 0.6) ? TILE_DIRT : TILE_GRASS_BASE + Math.floor(octaveNoise(x,y,seed+8000,2,4)*GRASS_VARIANTS); }
        if(this.tiles[i] >= TILE_GRASS_BASE && this.tiles[i] < TILE_GRASS_BASE+GRASS_VARIANTS) this.grassVariant[i] = this.tiles[i] - TILE_GRASS_BASE;
      }
    }
    const placeRnd = makeSeededRandom(seed+9999);
    for(let y=2; y<this.h-2; y++){
      for(let x=2; x<this.w-2; x++){
        const i = this.idx(x,y); const t = this.tiles[i]; if(t === TILE_WATER) continue;
        const b = biome[i]; let treeChance = 0.01; if(b >= 0.33 && b < 0.67) treeChance = 0.06; if(b >= 0.67) treeChance = 0.02;
        if(x < this.w-2 && y < this.h-2 && placeRnd() < treeChance){ let ok=true; for(let yy=y; yy<y+2; yy++) for(let xx=x; xx<x+2; xx++){ const idx2 = this.idx(xx,yy); if(this.tiles[idx2] === TILE_WATER) ok=false; if(this.objects[idx2] !== OBJ_NONE) ok=false; } if(ok){ for(let yy=y; yy<y+2; yy++) for(let xx=x; xx<x+2; xx++){ this.objects[this.idx(xx,yy)] = OBJ_TREE; } this.treeAnchor[i] = 1; continue; } }
        if(this.objects[i] === OBJ_NONE && placeRnd() < 0.025){ this.objects[i] = OBJ_ROCK; const maxOff = TILE*0.36; this.rockOffsetX[i] = (placeRnd()*2-1)*maxOff; this.rockOffsetY[i] = (placeRnd()*2-1)*maxOff; }
      }
    }
  }

  findSafeSpawn(){ const cx = Math.floor(this.w/2), cy = Math.floor(this.h/2); const maxR = Math.max(this.w,this.h); for(let r=0;r<maxR;r++){ for(let dy=-r; dy<=r; dy++){ for(let dx=-r; dx<=r; dx++){ const x = cx + dx; const y = cy + dy; if(!this.inBounds(x,y)) continue; const i=this.idx(x,y); if(this.tiles[i] === TILE_WATER) continue; if(this.objects[i] === OBJ_TREE) continue; let blocked=false; for(let yy=y-1; yy<=y+1; yy++) for(let xx=x-1; xx<=x+1; xx++){ if(!this.inBounds(xx,yy)){ blocked=true; break; } const idx2=this.idx(xx,yy); if(this.tiles[idx2] === TILE_WATER) blocked=true; if(this.objects[idx2] === OBJ_TREE) blocked=true; } if(blocked) continue; return {x: x*TILE + TILE/2, y: y*TILE + TILE/2}; } } } return {x: cx*TILE + TILE/2, y: cy*TILE + TILE/2}; }

  draw(ctx,camera,canvas,atlas){ const left = Math.max(0, Math.floor((camera.x - (canvas.width/2)/camera.scale)/TILE) - 1); const right = Math.min(this.w-1, Math.ceil((camera.x + (canvas.width/2)/camera.scale)/TILE) + 1); const top = Math.max(0, Math.floor((camera.y - (canvas.height/2)/camera.scale)/TILE) -1); const bottom = Math.min(this.h-1, Math.ceil((camera.y + (canvas.height/2)/camera.scale)/TILE) +1);
    for(let yy=top; yy<=bottom; yy++){ for(let xx=left; xx<=right; xx++){ const i=this.idx(xx,yy); const tile=this.tiles[i]; if(tile >= TILE_GRASS_BASE && tile < TILE_GRASS_BASE+GRASS_VARIANTS){ const varIdx = this.grassVariant[i]; ctx.drawImage(atlas, varIdx*TILE, 0, TILE, TILE, xx*TILE, yy*TILE, TILE, TILE); } else if(tile === TILE_DIRT){ ctx.drawImage(atlas, GRASS_VARIANTS*TILE, 0, TILE, TILE, xx*TILE, yy*TILE, TILE, TILE); } else { ctx.drawImage(atlas, (GRASS_VARIANTS+1)*TILE, 0, TILE, TILE, xx*TILE, yy*TILE, TILE, TILE); } } }
    for(let yy=top; yy<=bottom; yy++){ for(let xx=left; xx<=right; xx++){ const i=this.idx(xx,yy); const o=this.objects[i]; if(o === OBJ_ROCK){ const cx = xx*TILE + TILE/2 + this.rockOffsetX[i]; const cy = yy*TILE + TILE/2 + this.rockOffsetY[i]; drawRock(ctx, cx, cy); } else if(o === OBJ_TREE && this.treeAnchor[i]){ const cx = xx*TILE + TILE; const cy = yy*TILE + TILE; drawTreeLarge(ctx, cx, cy); } } } }
}

function drawRock(ctx,cx,cy){ ctx.save(); ctx.translate(cx,cy); ctx.beginPath(); ctx.ellipse(0,0,6,5,0,0,Math.PI*2); ctx.fillStyle='#6b665b'; ctx.fill(); ctx.strokeStyle='rgba(0,0,0,0.25)'; ctx.stroke(); ctx.restore(); }
function drawTreeLarge(ctx,cx,cy){ ctx.save(); ctx.translate(cx,cy); ctx.fillStyle='#6a4b2a'; ctx.fillRect(-6,6,12,12); ctx.beginPath(); ctx.ellipse(0,-4,26,20,0,0,Math.PI*2); ctx.fillStyle='#147a2c'; ctx.fill(); ctx.beginPath(); ctx.ellipse(-8,-14,18,14,0,0,Math.PI*2); ctx.fillStyle='#1aa13a'; ctx.fill(); ctx.beginPath(); ctx.ellipse(12,-12,14,10,0,0,Math.PI*2); ctx.fillStyle='#0f6b24'; ctx.fill(); ctx.restore(); }

function createTileAtlas(){ const off=document.createElement('canvas'); off.width=(GRASS_VARIANTS+2)*TILE; off.height=TILE; const oc=off.getContext('2d'); const grassColors=[['#7cc85b','#4fa043'],['#6fb23a','#4b8d2e'],['#8bdc66','#52a544'],['#5fb03a','#3f7b2a']]; for(let v=0; v<GRASS_VARIANTS; v++){ const gx=v*TILE; const g=oc.createLinearGradient(gx,0,gx+TILE,TILE); g.addColorStop(0,grassColors[v][0]); g.addColorStop(1,grassColors[v][1]); oc.fillStyle=g; oc.fillRect(gx,0,TILE,TILE); for(let i=0;i<40;i++){ oc.fillStyle=`rgba(0,0,0,${Math.random()*0.04})`; oc.fillRect(gx+Math.random()*TILE, Math.random()*TILE, 1,1); } } const dx=GRASS_VARIANTS*TILE; const dg=oc.createLinearGradient(dx,0,dx+TILE,TILE); dg.addColorStop(0,'#9f6b3a'); dg.addColorStop(1,'#7a4b2a'); oc.fillStyle=dg; oc.fillRect(dx,0,TILE,TILE); for(let i=0;i<30;i++){ oc.fillStyle=`rgba(0,0,0,${Math.random()*0.05})`; oc.fillRect(dx+Math.random()*TILE, Math.random()*TILE, 1,1); } const wx=(GRASS_VARIANTS+1)*TILE; const wg=oc.createLinearGradient(wx,0,wx+TILE,TILE); wg.addColorStop(0,'#3aa9df'); wg.addColorStop(1,'#1f6fa8'); oc.fillStyle=wg; oc.fillRect(wx,0,TILE,TILE); oc.globalAlpha=0.08; for(let i=0;i<3;i++){ oc.fillRect(wx + i*6 + 2, 6 + i*3, TILE-8, 2); } oc.globalAlpha=1; return off; }

// -----------------------------------------------------------------------------
class Input{ constructor(canvas){ this.keys={}; this.mouse={x:0,y:0,worldX:0,worldY:0}; canvas.addEventListener('mousemove', e=>{ const r=canvas.getBoundingClientRect(); this.mouse.x=e.clientX-r.left; this.mouse.y=e.clientY-r.top; }); canvas.addEventListener('wheel', e=>{ e.preventDefault(); if(!e.ctrlKey) camera.targetScale = clamp(camera.targetScale * (1 - e.deltaY * 0.0012), ZOOM_OUT_MIN, ZOOM_IN_MAX); }, {passive:false}); window.addEventListener('keydown', e=>{ this.keys[e.key.toLowerCase()] = true; }); window.addEventListener('keyup', e=>{ this.keys[e.key.toLowerCase()] = false; }); } isDown(k){ return !!this.keys[k.toLowerCase()]; } }

class Camera{ constructor(x=0,y=0,scale=CAMERA_DEFAULT){ this.x=x; this.y=y; this.scale=scale; this.targetScale=scale; this.smooth=0.12; this.zoomSmooth=0.12; } update(dt,tx,ty){ this.x = lerp(this.x, tx, this.smooth); this.y = lerp(this.y, ty, this.smooth); this.scale = lerp(this.scale, this.targetScale, this.zoomSmooth); } screenToWorld(sx,sy,canvas){ const wx = (sx - canvas.width/(2*DPR))/this.scale + this.x; const wy = (sy - canvas.height/(2*DPR))/this.scale + this.y; return {x:wx,y:wy}; } }

// -----------------------------------------------------------------------------
// Stamina system config — user asked: lower buffer to 1 and make drain faster
const STAMINA_MAX = 100;
const STAMINA_DRAIN_PER_SEC = 40; // increased (faster drain)
const STAMINA_RECOVER_PER_SEC = 18;

class Player{ constructor(x,y){ this.x=x; this.y=y; this.radius=10; this.baseSpeed=140; this.runMultiplier=1.9; this.angle=0; this.stamina = STAMINA_MAX; this.running=false; }
  update(dt,input,world,camera,canvas){ let vx=0,vy=0; if(input.isDown('w')||input.isDown('arrowup')) vy-=1; if(input.isDown('s')||input.isDown('arrowdown')) vy+=1; if(input.isDown('a')||input.isDown('arrowleft')) vx-=1; if(input.isDown('d')||input.isDown('arrowright')) vx+=1; const mag=Math.hypot(vx,vy); if(mag>0){ vx/=mag; vy/=mag; }
    // running logic: hold Shift to run if stamina > 1 (lowered buffer)
    const wantRun = input.isDown('shift');
    const canRun = wantRun && this.stamina > 1; // lowered from 4 to 1
    this.running = canRun;
    const speed = this.baseSpeed * (this.running ? this.runMultiplier : 1);

    const nx = this.x + vx*speed*dt; const ny = this.y + vy*speed*dt;

    const collides = (px,py) => {
      const tx = Math.floor(px/TILE), ty = Math.floor(py/TILE);
      const tile = world.getTile(tx,ty);
      if(tile === TILE_WATER) return true;
      // canopy ellipses collision
      for(let ay = ty-1; ay<=ty+1; ay++){
        for(let ax = tx-1; ax<=tx+1; ax++){
          if(!world.inBounds(ax,ay)) continue;
          const ai = world.idx(ax,ay);
          if(world.treeAnchor[ai]){
            const anchorX = ax; const anchorY = ay;
            const centerX = anchorX*TILE + TILE; const centerY = anchorY*TILE + TILE;
            const ellips = [ {dx:0, dy:-4, rx:26, ry:20}, {dx:-8, dy:-14, rx:18, ry:14}, {dx:12, dy:-12, rx:14, ry:10} ];
            for(const e of ellips){ const ex = centerX + e.dx; const ey = centerY + e.dy; const nxn = (px - ex)/e.rx; const nyn = (py - ey)/e.ry; if(nxn*nxn + nyn*nyn <= 1) return true; }
          }
        }
      }
      return false;
    };

    if(!collides(nx, this.y)) this.x = nx; if(!collides(this.x, ny)) this.y = ny;

    // stamina drain/recover
    if(this.running && (vx!==0 || vy!==0)){
      this.stamina -= STAMINA_DRAIN_PER_SEC * dt;
      if(this.stamina < 0) this.stamina = 0;
    } else {
      this.stamina += STAMINA_RECOVER_PER_SEC * dt;
      if(this.stamina > STAMINA_MAX) this.stamina = STAMINA_MAX;
    }

    const sEl = document.getElementById('staminaVal'); if(sEl) sEl.textContent = Math.round(this.stamina);

    const mw = camera.screenToWorld(input.mouse.x, input.mouse.y, canvas); this.angle = Math.atan2(mw.y - this.y, mw.x - this.x);
  }
  draw(ctx){ ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(this.angle); ctx.fillStyle = '#ffd8a8'; ctx.fillRect(-8, -8, 16, 16); ctx.fillStyle = '#2b2b2b'; ctx.fillRect(4, -4, 6, 6); ctx.fillStyle = 'rgba(0,0,0,0.15)'; ctx.fillRect(-7, 9, 14, 4); ctx.restore(); }
}

function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); } function lerp(a,b,t){ return a + (b-a)*t; }

// -----------------------------------------------------------------------------
const world = new World(MAP_W, MAP_H);
const atlas = createTileAtlas();
const spawn = world.findSafeSpawn();
const player = new Player(spawn.x, spawn.y);
const camera = new Camera(player.x, player.y, CAMERA_DEFAULT);
const input = new Input(canvas);

// adaptive stamina bar drawing — uses uiScale to enlarge on big screens
function drawStaminaBar(){ const bar = document.getElementById('stamina'); if(!bar) return; const pct = player.stamina / STAMINA_MAX; const w = Math.round(160 * uiScale); const h = Math.max(8, Math.round(10 * uiScale)); bar.style.minWidth = (w + Math.round(40 * uiScale)) + 'px'; const innerWidth = Math.round(pct * w); bar.innerHTML = `Stamina: <span id="staminaVal">${Math.round(player.stamina)}</span><div style="margin-top:${6*uiScale}px;background:rgba(255,255,255,0.08);width:${w}px;height:${h}px;border-radius:${6*uiScale}px;overflow:hidden"><div style="width:${innerWidth}px;height:${h}px;background:linear-gradient(90deg,#9be15d,#27ae60);"></div></div>`; bar.style.fontSize = Math.max(12, 13 * uiScale) + 'px'; bar.style.padding = (6 * uiScale) + 'px'; bar.style.left = (12 * uiScale) + 'px'; bar.style.bottom = (12 * uiScale) + 'px'; bar.style.borderRadius = (8 * uiScale) + 'px'; }

function loopUISync(){ drawStaminaBar(); requestAnimationFrame(loopUISync); }
requestAnimationFrame(loopUISync);

let last = performance.now(); function gameLoop(now){ const dt = Math.min((now-last)/1000, 1/15); last = now; player.update(dt,input,world,camera,canvas); camera.update(dt,player.x,player.y); const mw = camera.screenToWorld(input.mouse.x, input.mouse.y, canvas); input.mouse.worldX = mw.x; input.mouse.worldY = mw.y; render(); requestAnimationFrame(gameLoop); } requestAnimationFrame(gameLoop);

function render(){ ctx.setTransform(DPR,0,0,DPR,0,0); ctx.clearRect(0,0, canvas.width, canvas.height); ctx.setTransform(camera.scale*DPR,0,0,camera.scale*DPR, canvasW*DPR/2 - camera.x*camera.scale*DPR, canvasH*DPR/2 - camera.y*camera.scale*DPR); world.draw(ctx,camera,canvas,atlas); player.draw(ctx); ctx.save(); ctx.globalAlpha = 0.02; ctx.lineWidth = 1; ctx.strokeStyle = '#000'; const left = Math.floor((camera.x - (canvasW/2)/camera.scale)/TILE) - 1; const right = Math.ceil((camera.x + (canvasW/2)/camera.scale)/TILE) + 1; const top = Math.floor((camera.y - (canvasH/2)/camera.scale)/TILE) -1; const bottom = Math.ceil((camera.y + (canvasH/2)/camera.scale)/TILE) +1; for(let x=left;x<=right;x++){ ctx.beginPath(); ctx.moveTo(x*TILE, top*TILE); ctx.lineTo(x*TILE, bottom*TILE); ctx.stroke(); } for(let y=top;y<=bottom;y++){ ctx.beginPath(); ctx.moveTo(left*TILE, y*TILE); ctx.lineTo(right*TILE, y*TILE); ctx.stroke(); } ctx.restore(); }

</script>
</body>
</html>
