<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Minecraft Lite</title>
</head>
<body>
<canvas id="game"></canvas>
<script>
/*
  Minecraft Lite (2D, top-down)
  - Single-file HTML + JS
  - Controls: WASD to move, mouse rotates player toward cursor
  - Left click: break block (within range)
  - Right click: place dirt block (within range)
  - Camera follows player

  Code is modular and commented for easy tweaking.
*/

// ======= Config =======
const CONFIG = {
  title: 'Minecraft Lite',
  tileSize: 28,          // pixels per tile
  mapW: 128,             // tiles
  mapH: 128,             // tiles
  viewPadding: 3,        // extra tiles to draw beyond viewport
  playerSpeed: 160,      // pixels per second
  breakPlaceRange: 5,    // tiles
  seed: 12345,
};

// ======= Canvas setup =======
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
function resize() {
  canvas.width = innerWidth;
  canvas.height = innerHeight;
}
window.addEventListener('resize', resize);
resize();

// ======= Simple deterministic noise (value noise) =======
function hash(x, y, seed=CONFIG.seed){
  // 32-bit int hash
  let n = x * 374761393 + y * 668265263 + seed * 1442695040888963407 >>> 0;
  n = (n ^ (n >>> 13)) * 1274126177;
  n = (n ^ (n >>> 16)) >>> 0;
  return n / 4294967295;
}

// ======= World generation =======
// tile types: 0 = air, 1 = grass, 2 = dirt, 3 = stone, 4 = water
const map = new Uint8Array(CONFIG.mapW * CONFIG.mapH);
function generateWorld(){
  for(let y=0;y<CONFIG.mapH;y++){
    for(let x=0;x<CONFIG.mapW;x++){
      // layered noise for more natural shapes
      const n1 = hash(x, y, CONFIG.seed);
      const n2 = (hash(x*2, y*2, CONFIG.seed+1) + n1)/2;
      const n3 = (hash(Math.floor(x/3), Math.floor(y/3), CONFIG.seed+2) + n2)/2;
      const n = (n1 + n2*0.7 + n3*0.4) / (1 + 0.7 + 0.4);

      let t = 1; // grass default
      if(n < 0.15) t = 4;          // water
      else if(n < 0.45) t = 1;     // grass
      else if(n < 0.75) t = 2;     // dirt
      else t = 3;                  // stone

      // carve a small player spawn clearing near center
      const cx = Math.floor(CONFIG.mapW/2);
      const cy = Math.floor(CONFIG.mapH/2);
      if(Math.hypot(x-cx, y-cy) < 6) t = 1;

      map[y*CONFIG.mapW + x] = t;
    }
  }
}

function getTile(tx, ty){
  if(tx < 0 || ty < 0 || tx >= CONFIG.mapW || ty >= CONFIG.mapH) return 3; // treat out-of-bounds as stone
  return map[ty*CONFIG.mapW + tx];
}
function setTile(tx, ty, v){
  if(tx < 0 || ty < 0 || tx >= CONFIG.mapW || ty >= CONFIG.mapH) return;
  map[ty*CONFIG.mapW + tx] = v;
}
function tileSolid(t){
  // define which tiles block movement: all non-air and non-water
  return t !== 0 && t !== 4;
}

// ======= Player =======
const player = {
  x: (CONFIG.mapW/2) * CONFIG.tileSize + CONFIG.tileSize/2,
  y: (CONFIG.mapH/2) * CONFIG.tileSize + CONFIG.tileSize/2,
  radius: CONFIG.tileSize*0.4,
  angle: 0,
};

// ======= Input =======
const keys = {};
window.addEventListener('keydown', e => { keys[e.key.toLowerCase()] = true; });
window.addEventListener('keyup', e => { keys[e.key.toLowerCase()] = false; });

let mouse = {x: canvas.width/2, y: canvas.height/2, worldX: player.x, worldY: player.y};
canvas.addEventListener('mousemove', e => {
  mouse.x = e.clientX;
  mouse.y = e.clientY;
  // world coords will be computed in render loop after camera transform
});

canvas.addEventListener('mousedown', e => {
  const rect = canvas.getBoundingClientRect();
  const cx = rect.left + canvas.width/2 - (camera.x - player.x);
  // We'll compute world coords simpler in click handler below
});

// prevent context menu to use right click for placing
canvas.addEventListener('contextmenu', e => e.preventDefault());
canvas.addEventListener('mousedown', e => {
  const world = screenToWorld(e.clientX, e.clientY);
  const tx = Math.floor(world.x / CONFIG.tileSize);
  const ty = Math.floor(world.y / CONFIG.tileSize);
  const pdx = tx - Math.floor(player.x / CONFIG.tileSize);
  const pdy = ty - Math.floor(player.y / CONFIG.tileSize);
  const dist = Math.hypot(pdx, pdy);
  if(dist > CONFIG.breakPlaceRange) return; // out of range

  if(e.button === 0){ // left: break
    setTile(tx, ty, 0);
  } else if(e.button === 2){ // right: place dirt if empty
    if(getTile(tx, ty) === 0) setTile(tx, ty, 2);
  }
});

// ======= Camera =======
const camera = { x: player.x, y: player.y };
function updateCamera(){
  // simple camera that centers on player
  camera.x = player.x;
  camera.y = player.y;
}
function screenToWorld(sx, sy){
  // Convert screen coords to world coords given camera centered on screen
  const worldX = camera.x - canvas.width/2 + sx;
  const worldY = camera.y - canvas.height/2 + sy;
  return {x: worldX, y: worldY};
}

// ======= Movement and collision =======
function movePlayer(dx, dy, dt){
  if(dx === 0 && dy === 0) return;
  const speed = CONFIG.playerSpeed;
  // normalize
  const len = Math.hypot(dx, dy) || 1;
  const vx = dx / len * speed * dt;
  const vy = dy / len * speed * dt;

  // try move on X, check collision
  if(!collidesAt(player.x + vx, player.y)) player.x += vx;
  else {
    // attempt small slide: reduce movement
    if(!collidesAt(player.x + Math.sign(vx)*2, player.y)) player.x += Math.sign(vx)*2;
  }

  // try move on Y
  if(!collidesAt(player.x, player.y + vy)) player.y += vy;
  else {
    if(!collidesAt(player.x, player.y + Math.sign(vy)*2)) player.y += Math.sign(vy)*2;
  }
}

function collidesAt(px, py){
  // check four corners of player's bounding circle (approx with box)
  const r = player.radius;
  const corners = [
    {x: px - r, y: py - r},
    {x: px + r, y: py - r},
    {x: px - r, y: py + r},
    {x: px + r, y: py + r},
  ];
  for(const c of corners){
    const tx = Math.floor(c.x / CONFIG.tileSize);
    const ty = Math.floor(c.y / CONFIG.tileSize);
    if(tileSolid(getTile(tx, ty))) return true;
  }
  return false;
}

// ======= Rendering =======
function worldToScreen(wx, wy){
  return { x: wx - camera.x + canvas.width/2, y: wy - camera.y + canvas.height/2 };
}

function drawTile(t, sx, sy, size){
  // simple color palette
  if(t === 0){
    // air: draw background
    ctx.fillStyle = '#9ec7ff'; // sky-ish
    ctx.fillRect(sx, sy, size, size);
    return;
  }
  switch(t){
    case 1: ctx.fillStyle = '#5DB85B'; break; // grass
    case 2: ctx.fillStyle = '#9B6E4A'; break; // dirt
    case 3: ctx.fillStyle = '#8B8B8B'; break; // stone
    case 4: ctx.fillStyle = '#4AA3D6'; break; // water
    default: ctx.fillStyle = '#000';
  }
  ctx.fillRect(sx, sy, size, size);
  // subtle tile border for readability
  ctx.strokeStyle = 'rgba(0,0,0,0.05)';
  ctx.strokeRect(sx, sy, size, size);
}

function drawPlayer(){
  // compute on-screen position
  const p = worldToScreen(player.x, player.y);
  // triangle pointing toward angle
  ctx.save();
  ctx.translate(p.x, p.y);
  ctx.rotate(player.angle);
  // body
  ctx.beginPath();
  ctx.moveTo(player.radius, 0);
  ctx.lineTo(-player.radius*0.6, -player.radius*0.7);
  ctx.lineTo(-player.radius*0.6, player.radius*0.7);
  ctx.closePath();
  ctx.fillStyle = '#ffdd99';
  ctx.fill();
  // outline
  ctx.strokeStyle = 'rgba(0,0,0,0.6)';
  ctx.stroke();
  ctx.restore();
}

function render(){
  ctx.clearRect(0,0,canvas.width, canvas.height);

  const tileSize = CONFIG.tileSize;
  // compute visible tile range
  const left = Math.floor((camera.x - canvas.width/2) / tileSize) - CONFIG.viewPadding;
  const top = Math.floor((camera.y - canvas.height/2) / tileSize) - CONFIG.viewPadding;
  const right = Math.ceil((camera.x + canvas.width/2) / tileSize) + CONFIG.viewPadding;
  const bottom = Math.ceil((camera.y + canvas.height/2) / tileSize) + CONFIG.viewPadding;

  for(let ty = top; ty <= bottom; ty++){
    for(let tx = left; tx <= right; tx++){
      const t = getTile(tx, ty);
      const wx = tx * tileSize;
      const wy = ty * tileSize;
      const s = worldToScreen(wx, wy);
      drawTile(t, s.x, s.y, tileSize);
    }
  }

  drawPlayer();

  // HUD
  ctx.fillStyle = 'rgba(0,0,0,0.6)';
  ctx.font = '14px monospace';
  ctx.fillText(`x:${(player.x/tileSize).toFixed(2)} y:${(player.y/tileSize).toFixed(2)} ang:${(player.angle*180/Math.PI).toFixed(0)}Â°`, 12, 20);
  ctx.fillText('WASD - move   LMB - break   RMB - place dirt', 12, 40);
}

// ======= Main Loop =======
let last = performance.now();
function loop(now){
  const dt = Math.min((now - last)/1000, 0.05);
  last = now;

  // input -> velocity
  let dx = 0, dy = 0;
  if(keys['w']) dy -= 1;
  if(keys['s']) dy += 1;
  if(keys['a']) dx -= 1;
  if(keys['d']) dx += 1;
  movePlayer(dx, dy, dt);

  updateCamera();

  // update mouse world position and player angle
  const worldMouse = screenToWorld(mouse.x, mouse.y);
  mouse.worldX = worldMouse.x;
  mouse.worldY = worldMouse.y;
  player.angle = Math.atan2(mouse.worldY - player.y, mouse.worldX - player.x);

  render();
  requestAnimationFrame(loop);
}

// ======= Init =======
generateWorld();
requestAnimationFrame(loop);

// small helper: center canvas initial mouse
canvas.addEventListener('mouseenter', e => {
  mouse.x = e.clientX; mouse.y = e.clientY;
});

// make pointer visible and let right-click be used
canvas.style.cursor = 'crosshair';

// expose some utilities to console for debugging
window.MinecraftLite = { CONFIG, player, getTile, setTile, map };
</script>
</body>
</html>
