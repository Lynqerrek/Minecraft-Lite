<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>MineLite — Minimal Playable</title>
  <style>
    html,body{height:100%;margin:0;background:#7ec0ff;overflow:hidden;font-family:Inter,Arial,Helvetica,sans-serif}
    canvas{display:block}
    #ui{position:fixed;left:12px;bottom:12px;color:#111}
    #instr{position:fixed;left:12px;top:12px;background:rgba(255,255,255,0.9);padding:8px;border-radius:8px}
    .slot{width:36px;height:36px;border-radius:6px;background:rgba(0,0,0,0.06);display:inline-flex;align-items:center;justify-content:center;margin-right:6px}
    #fps{position:fixed;right:12px;top:12px;background:rgba(255,255,255,0.9);padding:6px;border-radius:6px}
  </style>
</head>
<body>
  <div id="instr">MineLite — Minimal. WASD move • Space jump • Shift sprint • Click to interact</div>
  <div id="fps">FPS: <span id="fpsVal">0</span></div>

  <script src="https://unpkg.com/three@0.154.0/build/three.min.js"></script>
  <script>
  // Minimal MineLite: simplified, immediate start, basic movement + collisions + face culling per voxel

  // ---- Config ----
  const WORLD = { x:48, z:48, y:32 };
  const CHUNK = 16;
  const SEED = 1337;
  const BLOCKS = [ {id:0,name:'air',color:0x000000}, {id:1,name:'grass',color:0x6dbf3f}, {id:2,name:'dirt',color:0x8b5222}, {id:3,name:'stone',color:0x8a8a8a} ];
  let selectedBlock = 1;
  const PLAYER = {height:1.8, eye:1.62, radius:0.28, speed:4.2, sprint:1.6};

  // ---- Storage & utils ----
  const world = new Uint8Array(WORLD.x * WORLD.y * WORLD.z);
  function idx(x,y,z){ return x + z*WORLD.x + y*WORLD.x*WORLD.z }
  function inBounds(x,y,z){ return x>=0&&y>=0&&z>=0&&x<WORLD.x&&y<WORLD.y&&z<WORLD.z }
  function getBlock(x,y,z){ if(!inBounds(x,y,z)) return 0; return world[idx(x,y,z)]; }
  function setBlock(x,y,z,id){ if(!inBounds(x,y,z)) return; world[idx(x,y,z)] = id; }

  // small seeded RNG
  function RNG(seed){ let s=seed; return ()=>{ s=(s*1664525+1013904223)>>>0; return s/4294967296; } }

  // simple heightmap
  function generate(){
    const r = RNG(SEED);
    for(let x=0;x<WORLD.x;x++){
      for(let z=0;z<WORLD.z;z++){
        const nx = x/(WORLD.x/6), nz = z/(WORLD.z/6);
        // pseudo-noise with a few sines + rand to avoid heavy noise code
        const e = Math.sin(nx*1.3) * 1.0 + Math.cos(nz*0.9)*0.7 + (r()-0.5)*0.5;
        const h = Math.max(3, Math.floor((e+1.5)*4));
        for(let y=0;y<WORLD.y;y++){
          let id = 0;
          if(y <= h-1){ id = (y===h-1)?1:(y>h-4?2:3); }
          world[idx(x,y,z)] = id;
        }
      }
    }
  }

  // ---- Three.js setup ----
  const scene = new THREE.Scene(); scene.background = new THREE.Color(0x7ec0ff);
  const camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 1000);
  const renderer = new THREE.WebGLRenderer({antialias:true}); renderer.setSize(innerWidth, innerHeight); document.body.appendChild(renderer.domElement);
  scene.add(new THREE.HemisphereLight(0xffffff,0x444444,0.9)); const dir = new THREE.DirectionalLight(0xffffff,0.6); dir.position.set(-5,10,-5); scene.add(dir);

  // ---- Face culling and chunk building (simple) ----
  const FACES = [
    {dir:[1,0,0], verts:[[1,0,0],[1,1,0],[1,1,1],[1,0,1]], normal:[1,0,0]},
    {dir:[-1,0,0], verts:[[0,0,1],[0,1,1],[0,1,0],[0,0,0]], normal:[-1,0,0]},
    {dir:[0,1,0], verts:[[0,1,1],[1,1,1],[1,1,0],[0,1,0]], normal:[0,1,0]},
    {dir:[0,-1,0], verts:[[0,0,0],[1,0,0],[1,0,1],[0,0,1]], normal:[0,-1,0]},
    {dir:[0,0,1], verts:[[0,0,1],[1,0,1],[1,1,1],[0,1,1]], normal:[0,0,1]},
    {dir:[0,0,-1], verts:[[1,0,0],[0,0,0],[0,1,0],[1,1,0]], normal:[0,0,-1]}
  ];

  const chunks = {};
  function chunkKey(cx,cz){ return cx+":"+cz }
  function buildChunk(cx,cz){
    const minX = cx*CHUNK, minZ = cz*CHUNK; const maxX = Math.min(minX+CHUNK, WORLD.x), maxZ=Math.min(minZ+CHUNK, WORLD.z);
    const pos=[], norm=[], col=[], idxs=[]; let ic=0;
    for(let x=minX;x<maxX;x++) for(let z=minZ; z<maxZ; z++) for(let y=0;y<WORLD.y;y++){
      const b = getBlock(x,y,z); if(b===0) continue;
      for(const f of FACES){ const nx=x+f.dir[0], ny=y+f.dir[1], nz=z+f.dir[2]; const n = inBounds(nx,ny,nz)?getBlock(nx,ny,nz):0; if(n!==0) continue; const bx = x - WORLD.x/2, by = y, bz = z - WORLD.z/2; for(let i=0;i<4;i++){ const v=f.verts[i]; pos.push(bx+v[0], by+v[1], bz+v[2]); norm.push(...f.normal); const c=new THREE.Color(BLOCKS[b].color); col.push(c.r,c.g,c.b); } idxs.push(ic,ic+1,ic+2,ic,ic+2,ic+3); ic+=4; }
    }
    if(pos.length===0){ const g=new THREE.BufferGeometry(); g.setAttribute('position', new THREE.Float32BufferAttribute([0,0,0],3)); return new THREE.Mesh(g,new THREE.MeshBasicMaterial({visible:false})); }
    const geo = new THREE.BufferGeometry(); geo.setAttribute('position', new THREE.Float32BufferAttribute(pos,3)); geo.setAttribute('normal', new THREE.Float32BufferAttribute(norm,3)); geo.setAttribute('color', new THREE.Float32BufferAttribute(col,3)); geo.setIndex(idxs); geo.computeBoundingSphere(); geo.computeBoundingBox(); const mat = new THREE.MeshStandardMaterial({vertexColors:true}); const mesh = new THREE.Mesh(geo, mat); mesh.frustumCulled=true; return mesh;
  }

  function buildAll(){ for(const k in chunks){ if(chunks[k].mesh){ scene.remove(chunks[k].mesh); try{ chunks[k].mesh.geometry.dispose(); chunks[k].mesh.material.dispose(); }catch(e){} } }
    const cxCount = Math.ceil(WORLD.x/CHUNK), czCount=Math.ceil(WORLD.z/CHUNK); for(let cx=0;cx<cxCount;cx++) for(let cz=0;cz<czCount;cz++){ const m = buildChunk(cx,cz); scene.add(m); chunks[chunkKey(cx,cz)] = {mesh:m,cx,cz}; } }

  // generate and build now (synchronous, small world)
  generate(); buildAll();

  // ---- Player & controls ----
  const player = new THREE.Vector3(0, 18, 0);
  const velocity = new THREE.Vector3(); let canJump=false; const keys={f:0,b:0,l:0,r:0}; let sprint=false;
  function onDown(e){ if(e.code==='KeyW') keys.f=1; if(e.code==='KeyS') keys.b=1; if(e.code==='KeyA') keys.l=1; if(e.code==='KeyD') keys.r=1; if(e.code==='ShiftLeft' || e.code==='ShiftRight') sprint=true; if(e.code==='Space' && canJump){ velocity.y = 7; canJump=false; } }
  function onUp(e){ if(e.code==='KeyW') keys.f=0; if(e.code==='KeyS') keys.b=0; if(e.code==='KeyA') keys.l=0; if(e.code==='KeyD') keys.r=0; if(e.code==='ShiftLeft' || e.code==='ShiftRight') sprint=false; }
  window.addEventListener('keydown', onDown); window.addEventListener('keyup', onUp);

  // mouse look (pointerlock optional)
  const yaw = new THREE.Object3D(); const pitch = new THREE.Object3D(); yaw.add(pitch); pitch.add(camera); scene.add(yaw); yaw.position.copy(player);
  renderer.domElement.addEventListener('click', ()=>{ renderer.domElement.requestPointerLock?.(); });
  document.addEventListener('pointermove', (e)=>{ if(document.pointerLockElement !== renderer.domElement) return; yaw.rotation.y -= e.movementX*0.0025; pitch.rotation.x -= e.movementY*0.0025; pitch.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, pitch.rotation.x)); });

  // basic AABB collision helpers
  function isSolid(x,y,z){ return inBounds(x,y,z) && getBlock(x,y,z)!==0; }
  function movePlayer(dx,dy,dz){
    // per-axis resolution
    function overlap(minX,minY,minZ,maxX,maxY,maxZ){ const hits=[]; for(let bx=Math.floor(minX); bx<=Math.floor(maxX); bx++) for(let by=Math.floor(minY); by<=Math.floor(maxY); by++) for(let bz=Math.floor(minZ); bz<=Math.floor(maxZ); bz++) if(isSolid(bx,by,bz)) hits.push([bx,by,bz]); return hits; }
    // X
    if(dx!==0){ const minX=player.x-PLAYER.radius+Math.min(0,dx), maxX=player.x+PLAYER.radius+Math.max(0,dx); const hits=overlap(minX,player.y,player.z-PLAYER.radius,maxX,player.y+PLAYER.height-1e-6,player.z+PLAYER.radius); let adj=dx; for(const h of hits){ const bx=h[0]; if(dx>0){ const pen=bx-(player.x+PLAYER.radius); if(pen<adj) adj=Math.min(adj,pen); } else { const pen=(bx+1)-(player.x-PLAYER.radius); if(pen>adj) adj=Math.max(adj,pen); } } player.x+=adj; }
    // Z
    if(dz!==0){ const minZ=player.z-PLAYER.radius+Math.min(0,dz), maxZ=player.z+PLAYER.radius+Math.max(0,dz); const hits=overlap(player.x-PLAYER.radius,player.y,minZ,player.x+PLAYER.radius,player.y+PLAYER.height-1e-6,maxZ); let adj=dz; for(const h of hits){ const bz=h[2]; if(dz>0){ const pen=bz-(player.z+PLAYER.radius); if(pen<adj) adj=Math.min(adj,pen); } else { const pen=(bz+1)-(player.z-PLAYER.radius); if(pen>adj) adj=Math.max(adj,pen); } } player.z+=adj; }
    // Y
    if(dy!==0){ const minY=player.y+Math.min(0,dy), maxY=player.y+PLAYER.height+Math.max(0,dy)-1e-6; const hits=overlap(player.x-PLAYER.radius,minY,player.z-PLAYER.radius,player.x+PLAYER.radius,maxY,player.z+PLAYER.radius); let adj=dy; for(const h of hits){ const by=h[1]; if(dy>0){ const pen=by-(player.y+PLAYER.height); if(pen<adj) adj=Math.min(adj,pen); } else { const pen=(by+1)-player.y; if(pen>adj) adj=Math.max(adj,pen); } } player.y += adj; if(dy<0 && Math.abs(adj-dy)>1e-5) canJump=true; if(dy>0 && Math.abs(adj-dy)>1e-5) velocity.y=0; }
  }

  function onGround(){ const minY=player.y-0.05, maxY=player.y+0.05; for(let bx=Math.floor(player.x-PLAYER.radius); bx<=Math.floor(player.x+PLAYER.radius); bx++) for(let by=Math.floor(minY); by<=Math.floor(maxY); by++) for(let bz=Math.floor(player.z-PLAYER.radius); bz<=Math.floor(player.z+PLAYER.radius); bz++) if(isSolid(bx,by,bz)) return true; return false; }

  // interactions (break/place)
  function rayTarget(){ const origin = camera.position.clone(); const dir = new THREE.Vector3(); camera.getWorldDirection(dir); const step=0.2, max=6, steps=Math.floor(max/step); let last=null; for(let i=0;i<steps;i++){ const p = origin.clone().addScaledVector(dir, i*step); const gx=Math.floor(p.x+WORLD.x/2), gy=Math.floor(p.y), gz=Math.floor(p.z+WORLD.z/2); if(!inBounds(gx,gy,gz)) continue; const b=getBlock(gx,gy,gz); if(b!==0) return {hit:true,pos:[gx,gy,gz],place:last}; last=[gx,gy,gz]; } return {hit:false,place:last}; }
  window.addEventListener('mousedown',(e)=>{ if(document.pointerLockElement!==renderer.domElement) return; const t=rayTarget(); if(e.button===0 && t.hit){ setBlock(...t.pos,0); rebuildChunk(t.pos[0],t.pos[2]); } if(e.button===2 && t.place){ setBlock(...t.place, selectedBlock); rebuildChunk(t.place[0],t.place[2]); } }); window.addEventListener('contextmenu', e=>e.preventDefault());

  // rebuild single chunk
  function rebuildChunk(x,z){ const cx=Math.floor(x/CHUNK), cz=Math.floor(z/CHUNK), k=chunkKey(cx,cz); const old = chunks[k]; if(old && old.mesh){ scene.remove(old.mesh); try{ old.mesh.geometry.dispose(); old.mesh.material.dispose(); }catch(e){} } const m = buildChunk(cx,cz); scene.add(m); chunks[k] = {mesh:m,cx,cz}; }

  // camera initial placement
  yaw.position.copy(player);
  function updateCamera(){ camera.position.set(player.x, player.y + PLAYER.eye, player.z); }

  // hotbar simple
  const hotbar = document.createElement('div'); hotbar.style.position='fixed'; hotbar.style.left='12px'; hotbar.style.bottom='12px'; document.body.appendChild(hotbar);
  for(let i=1;i<BLOCKS.length;i++){ const s=document.createElement('div'); s.className='slot'; s.textContent = BLOCKS[i].name[0].toUpperCase(); s.onclick = ()=>{ selectedBlock = BLOCKS[i].id; s.style.outline='3px solid rgba(0,0,0,0.6)'; }; hotbar.appendChild(s); }

  // resize
  window.addEventListener('resize', ()=>{ camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix(); renderer.setSize(innerWidth, innerHeight); });

  // main loop (starts immediately)
  let prev = performance.now(), fpsC=0, fpsT=performance.now(); function loop(){ const now = performance.now(); const dt = Math.min(0.05, (now-prev)/1000); prev = now;
    // input
    const f = keys.f-keys.b, s = keys.r-keys.l; let sp = PLAYER.speed * (sprint?PLAYER.sprint:1);
    const fw = new THREE.Vector3(); yaw.getWorldDirection(fw); fw.y=0; fw.normalize(); const rt = new THREE.Vector3(); rt.crossVectors(new THREE.Vector3(0,1,0), fw).normalize(); const desired = new THREE.Vector3(); desired.addScaledVector(fw, f*sp); desired.addScaledVector(rt, s*sp);
    velocity.x += (desired.x - velocity.x) * 10 * dt; velocity.z += (desired.z - velocity.z) * 10 * dt; velocity.y -= 20 * dt;
    let dx = velocity.x * dt, dy = velocity.y * dt, dz = velocity.z * dt;
    const orig = player.clone(); movePlayer(dx, dy, dz);
    if((Math.abs(player.x - (orig.x + dx))>1e-5 || Math.abs(player.z - (orig.z + dz))>1e-5) && onGround()){
      const step = 0.5; player.y += step; movePlayer(dx,0,dz); if(Math.abs(player.x - (orig.x + dx))>1e-5 || Math.abs(player.z - (orig.z + dz))>1e-5) player.y = orig.y; }
    if(Math.abs(velocity.x)<0.01) velocity.x = 0; if(Math.abs(velocity.z)<0.01) velocity.z = 0; if(onGround()){ canJump = true; velocity.y = Math.max(velocity.y, -1); }
    yaw.position.set(player.x, player.y + PLAYER.eye, player.z); updateCamera(); renderer.render(scene, camera);
    fpsC++; if(now - fpsT > 500){ document.getElementById('fpsVal').textContent = Math.round((fpsC*1000)/(now-fpsT)); fpsT = now; fpsC = 0; }
    requestAnimationFrame(loop);
  }

  // prepare yaw/pitch, start immediately
  const yaw = new THREE.Object3D(); const pitch = new THREE.Object3D(); yaw.add(pitch); pitch.add(camera); scene.add(yaw);
  // set initial player position to spawn above ground
  player.x = Math.floor(WORLD.x/2); player.z = Math.floor(WORLD.z/2);
  for(let y=0;y<WORLD.y;y++){ if(getBlock(player.x,y,player.z)!==0) player.y = y+2; }
  yaw.position.copy(player);
  updateCamera(); loop();
  </script>
</body>
</html>
