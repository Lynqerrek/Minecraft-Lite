<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>2D Top-Down Minecraft-like (simple)</title>
  <style>
    html,body{height:100%;margin:0;background:#0b1220;color:#ddd;font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}
    .wrap{display:flex;align-items:center;justify-content:center;height:100%;}
    canvas{background:#7ec850;box-shadow:0 8px 30px rgba(0,0,0,.5);border-radius:6px}
    .hud{position:fixed;left:12px;top:12px;color:#fff;background:rgba(0,0,0,.25);padding:8px;border-radius:6px;font-size:13px}
    .hint{opacity:.85}
  </style>
</head>
<body>
  <div class="wrap">
    <canvas id="game"></canvas>
  </div>
  <div class="hud">
    <div><strong>Controls</strong></div>
    <div class="hint">WASD / Arrow keys — move</div>
    <div class="hint">Mouse — aim (player rotates to cursor)</div>
    <div class="hint">Scroll — zoom (optional)</div>
  </div>

<script>
// 2D top-down, tile-based, simple "Minecraft-like" demo
// Features:
// - Large tile map with simple solid tiles
// - Player moves with WASD / arrow keys
// - Player rotates to face the cursor (world coords)
// - Camera follows player with smoothing and a slight zoom-out
// - Minimal, well-commented single-file implementation

// -----------------------------------------------------------------------------
// Config
const TILE = 32;               // tile pixel size
const MAP_W = 80;              // map width in tiles
const MAP_H = 60;              // map height in tiles
const CANVAS_BASE_W = 1280;    // initial canvas size
const CANVAS_BASE_H = 720;

// -----------------------------------------------------------------------------
// Utilities
function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }
function lerp(a,b,t){ return a + (b-a)*t; }

// -----------------------------------------------------------------------------
// Input handling
class Input {
  constructor(canvas){
    this.keys = {};
    this.mouse = {x:0,y:0, worldX:0, worldY:0};
    canvas.addEventListener('mousemove', e => {
      const rect = canvas.getBoundingClientRect();
      this.mouse.x = e.clientX - rect.left;
      this.mouse.y = e.clientY - rect.top;
    });
    canvas.addEventListener('wheel', e => {
      e.preventDefault();
      camera.targetScale = clamp(camera.targetScale * (1 - e.deltaY * 0.0015), 0.6, 1.2);
    }, {passive:false});

    window.addEventListener('keydown', e => { this.keys[e.key.toLowerCase()] = true; });
    window.addEventListener('keyup', e => { this.keys[e.key.toLowerCase()] = false; });
  }
  isDown(k){ return !!this.keys[k.toLowerCase()]; }
}

// -----------------------------------------------------------------------------
// Camera — simple follow with smoothing and scale
class Camera {
  constructor(x=0,y=0, scale=0.85){
    this.x = x; this.y = y; // center in world coords
    this.scale = scale;     // current scale (world -> screen)
    this.targetScale = scale;
    this.smooth = 0.12;     // smoothing for position
    this.zoomSmooth = 0.12;  // smoothing for zoom
  }
  update(dt, targetX, targetY){
    // gently follow target
    this.x = lerp(this.x, targetX, this.smooth);
    this.y = lerp(this.y, targetY, this.smooth);
    // smoothly change zoom
    this.scale = lerp(this.scale, this.targetScale, this.zoomSmooth);
  }
  // Convert mouse screen -> world coordinates
  screenToWorld(sx, sy, canvas){
    const wx = (sx - canvas.width/2)/this.scale + this.x;
    const wy = (sy - canvas.height/2)/this.scale + this.y;
    return {x: wx, y: wy};
  }
}

// -----------------------------------------------------------------------------
// World / map
class World {
  constructor(w,h){
    this.w = w; this.h = h;
    this.tiles = new Uint8Array(w*h);
    this.generate();
  }
  idx(x,y){ return y*this.w + x; }
  getTile(x,y){ if(x<0||y<0||x>=this.w||y>=this.h) return 1; return this.tiles[this.idx(x,y)]; }
  setTile(x,y,val){ if(x<0||y<0||x>=this.w||y>=this.h) return; this.tiles[this.idx(x,y)] = val; }
  generate(){
    // Simple generation: mostly grass (0), scattered dirt/stone (1 solid)
    for(let y=0;y<this.h;y++){
      for(let x=0;x<this.w;x++){
        // border walls
        if(x===0||y===0||x===this.w-1||y===this.h-1){ this.setTile(x,y,1); continue; }
        const r = Math.random();
        if(r < 0.06) this.setTile(x,y,1);
        else this.setTile(x,y,0);
      }
    }
    // create a few rectangular "mines" and clusters
    for(let i=0;i<60;i++){
      const cx = Math.floor(Math.random()*(this.w-8))+4;
      const cy = Math.floor(Math.random()*(this.h-8))+4;
      const rw = Math.floor(Math.random()*4)+2;
      const rh = Math.floor(Math.random()*4)+2;
      for(let yy=cy-rh; yy<cy+rh; yy++) for(let xx=cx-rw; xx<cx+rw; xx++) if(Math.random()<0.85) this.setTile(xx,yy,1);
    }
  }
  draw(ctx, camera, canvas){
    // compute visible tile range
    const left = Math.floor((camera.x - (canvas.width/2)/camera.scale)/TILE) - 1;
    const right = Math.ceil((camera.x + (canvas.width/2)/camera.scale)/TILE) + 1;
    const top = Math.floor((camera.y - (canvas.height/2)/camera.scale)/TILE) -1;
    const bottom = Math.ceil((camera.y + (canvas.height/2)/camera.scale)/TILE) +1;

    for(let y = top; y <= bottom; y++){
      for(let x = left; x <= right; x++){
        const tile = this.getTile(x,y);
        const sx = x * TILE;
        const sy = y * TILE;
        if(tile === 0){
          // grass
          ctx.fillStyle = '#69b23a';
          ctx.fillRect(sx, sy, TILE, TILE);
          // simple noise
          ctx.fillStyle = 'rgba(0,0,0,0.03)';
          if((x+y)%7===0) ctx.fillRect(sx+4, sy+4, 2, 2);
        } else {
          // solid block (dirt/stone)
          ctx.fillStyle = '#8b5a2b';
          ctx.fillRect(sx, sy, TILE, TILE);
          ctx.strokeStyle = 'rgba(0,0,0,0.12)';
          ctx.strokeRect(sx+1, sy+1, TILE-2, TILE-2);
        }
      }
    }
  }
}

// -----------------------------------------------------------------------------
// Player
class Player {
  constructor(x,y){
    this.x = x; this.y = y;
    this.radius = 12;
    this.speed = 160; // pixels/sec
    this.angle = 0;    // facing direction
  }
  update(dt, input, world, camera, canvas){
    // Movement vector from input
    let vx = 0, vy = 0;
    if(input.isDown('w') || input.isDown('arrowup')) vy -= 1;
    if(input.isDown('s') || input.isDown('arrowdown')) vy += 1;
    if(input.isDown('a') || input.isDown('arrowleft')) vx -= 1;
    if(input.isDown('d') || input.isDown('arrowright')) vx += 1;
    // normalize
    const mag = Math.hypot(vx,vy);
    if(mag>0){ vx/=mag; vy/=mag; }

    // move with collision against solid tiles
    const nx = this.x + vx * this.speed * dt;
    const ny = this.y + vy * this.speed * dt;

    // collision check function
    const collides = (px,py) => {
      const tx = Math.floor(px / TILE);
      const ty = Math.floor(py / TILE);
      return world.getTile(tx,ty) === 1;
    };

    // simple axis separation
    if(!collides(nx, this.y)) this.x = nx;
    if(!collides(this.x, ny)) this.y = ny;

    // compute angle to cursor (mouse in world coords)
    const mw = camera.screenToWorld(input.mouse.x, input.mouse.y, canvas);
    this.angle = Math.atan2(mw.y - this.y, mw.x - this.x);
  }
  draw(ctx){
    ctx.save();
    ctx.translate(this.x, this.y);
    ctx.rotate(this.angle);
    // draw a simple player: triangle pointing right
    ctx.beginPath();
    ctx.moveTo(16, 0);
    ctx.lineTo(-10, -10);
    ctx.lineTo(-10, 10);
    ctx.closePath();
    ctx.fillStyle = '#2b8cff';
    ctx.fill();
    // outline / eye
    ctx.beginPath(); ctx.arc(6, -3, 2, 0, Math.PI*2); ctx.fillStyle = '#fff'; ctx.fill();
    ctx.restore();
  }
}

// -----------------------------------------------------------------------------
// Setup
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
resizeCanvas();
window.addEventListener('resize', resizeCanvas);

const world = new World(MAP_W, MAP_H);
const player = new Player(MAP_W*TILE/2, MAP_H*TILE/2);
const camera = new Camera(player.x, player.y, 0.85); // slight zoom out
const input = new Input(canvas);

let last = performance.now();
function gameLoop(now){
  const dt = Math.min((now - last)/1000, 1/15);
  last = now;

  player.update(dt, input, world, camera, canvas);
  camera.update(dt, player.x, player.y);

  // update mouse world coords (convenience)
  const mw = camera.screenToWorld(input.mouse.x, input.mouse.y, canvas);
  input.mouse.worldX = mw.x; input.mouse.worldY = mw.y;

  render();
  requestAnimationFrame(gameLoop);
}
requestAnimationFrame(gameLoop);

// -----------------------------------------------------------------------------
// Rendering
function render(){
  // clear
  ctx.setTransform(1,0,0,1,0,0);
  ctx.clearRect(0,0,canvas.width,canvas.height);

  // apply camera transform: scale and center camera.x/camera.y at canvas center
  ctx.setTransform(camera.scale, 0, 0, camera.scale, canvas.width/2 - camera.x*camera.scale, canvas.height/2 - camera.y*camera.scale);

  // draw world
  world.draw(ctx, camera, canvas);

  // draw player
  player.draw(ctx);

  // optional: draw cursor marker in world coords for clarity
  ctx.save();
  const mw = {x: input.mouse.worldX, y: input.mouse.worldY};
  ctx.beginPath(); ctx.arc(mw.x, mw.y, 4, 0, Math.PI*2); ctx.fillStyle='rgba(0,0,0,0.6)'; ctx.fill();
  ctx.restore();

  // draw simple grid lines (subtle)
  ctx.save();
  ctx.globalAlpha = 0.04;
  ctx.lineWidth = 1;
  ctx.strokeStyle = '#000';
  const left = Math.floor((camera.x - (canvas.width/2)/camera.scale)/TILE) - 1;
  const right = Math.ceil((camera.x + (canvas.width/2)/camera.scale)/TILE) + 1;
  const top = Math.floor((camera.y - (canvas.height/2)/camera.scale)/TILE) -1;
  const bottom = Math.ceil((camera.y + (canvas.height/2)/camera.scale)/TILE) +1;
  for(let x = left; x<=right; x++){ ctx.beginPath(); ctx.moveTo(x*TILE, top*TILE); ctx.lineTo(x*TILE, bottom*TILE); ctx.stroke(); }
  for(let y = top; y<=bottom; y++){ ctx.beginPath(); ctx.moveTo(left*TILE, y*TILE); ctx.lineTo(right*TILE, y*TILE); ctx.stroke(); }
  ctx.restore();

  // reset transform for HUD or debug
  ctx.setTransform(1,0,0,1,0,0);
}

// -----------------------------------------------------------------------------
// Resize logic keeps canvas aspect ratio and pixel ratio in mind
function resizeCanvas(){
  // make canvas fill most of the window but keep base aspect
  const vw = Math.max(600, Math.min(window.innerWidth - 40, CANVAS_BASE_W));
  const vh = Math.max(360, Math.min(window.innerHeight - 40, CANVAS_BASE_H));
  canvas.width = vw; canvas.height = vh;
}

</script>
</body>
</html>
