<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>MineLite — 2D Top-Down</title>
<style>
html,body{height:100%;margin:0;background:#0b1220;color:#ddd;font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;overflow:hidden}
canvas{display:block}
.hud{position:fixed;left:12px;top:12px;color:#fff;background:rgba(0,0,0,.28);padding:8px;border-radius:6px;font-size:13px;pointer-events:none}
.title{font-weight:700;margin-bottom:6px}
.hint{opacity:.9}
.stamina{position:fixed;left:12px;bottom:12px;padding:6px;background:rgba(0,0,0,0.32);border-radius:8px;color:#fff;font-family:monospace;pointer-events:none}
</style>
</head>
<body>
<canvas id="game"></canvas>
<div id="hud" class="hud">
<div class="title">MineLite</div>
<div><strong>Controls</strong></div>
<div class="hint">WASD / Arrows — move</div>
<div class="hint">Hold Shift — run (uses stamina)</div>
<div class="hint">Mouse — aim</div>
<div class="hint">Scroll — zoom (Ctrl+Scroll disabled)</div>
</div>
<div id="stamina" class="stamina">Stamina: <span id="staminaVal">100</span></div>
<script>
const TILE=32, MAP_W=160, MAP_H=110; const DPR=window.devicePixelRatio||1;
const GRASS_VARIANTS=4, TILE_GRASS_BASE=0, TILE_DIRT=GRASS_VARIANTS, TILE_WATER=GRASS_VARIANTS+1;
const OBJ_NONE=0, OBJ_ROCK=1, OBJ_TREE=2; const BARRIER_THICKNESS=Math.max(10,Math.floor(Math.min(MAP_W,MAP_H)*0.12))*2;
const ZOOM_IN_MAX=3.6, ZOOM_OUT_MIN=ZOOM_IN_MAX/1.5, CAMERA_DEFAULT=(ZOOM_IN_MAX+ZOOM_OUT_MIN)/2;
const STAMINA_MAX=100, STAMINA_DRAIN_PER_SEC=13, STAMINA_RECOVER_PER_SEC=18; // drain reduced, stamina bigger

function makeSeededRandom(seed){let s=seed>>>0;return function(){s=(s+0x6D2B79F5)|0;let t=Math.imul(s^s>>>15,1|s);t=(t+Math.imul(t^t>>>7,61|t))^t;return((t^t>>>14)>>>0)/4294967296;}} 
function smoothstep(a){return a*a*(3-2*a);} 
function valueNoise2D(x,y,seed){const xf=Math.floor(x),yf=Math.floor(y);const rx=x-xf,ry=y-yf;const u=smoothstep(rx),v=smoothstep(ry);const r00=makeSeededRandom(((xf*73856093)^(yf*19349663)^seed)>>>0)();const r10=makeSeededRandom((((xf+1)*73856093)^(yf*19349663)^seed)>>>0)();const r01=makeSeededRandom(((xf*73856093)^((yf+1)*19349663)^seed)>>>0)();const r11=makeSeededRandom((((xf+1)*73856093)^((yf+1)*19349663)^seed)>>>0)();const xa=r00*(1-u)+r10*u;const xb=r01*(1-u)+r11*u;return xa*(1-v)+xb*v;} 
function octaveNoise(x,y,seed,oct=4,scale=1){let amp=1,freq=1,sum=0,tot=0;for(let i=0;i<oct;i++){sum+=valueNoise2D(x*freq/scale,y*freq/scale,seed+i*1000)*amp;tot+=amp;amp*=0.5;freq*=2;}return sum/tot;}

const canvas=document.getElementById('game');const ctx=canvas.getContext('2d');
let canvasW=0,canvasH=0,uiScale=DPR;
function resizeCanvas(){canvasW=Math.max(320,window.innerWidth);canvasH=Math.max(240,window.innerHeight);canvas.style.width=canvasW+'px';canvas.style.height=canvasH+'px';canvas.width=Math.floor(canvasW*DPR);canvas.height=Math.floor(canvasH*DPR);ctx.setTransform(DPR,0,0,DPR,0,0);const baselineW=1920,baselineH=1080;const ratio=Math.min(canvasW/baselineW,canvasH/baselineH);uiScale=Math.max(1,ratio)*DPR;styleHUD();} window.addEventListener('resize',resizeCanvas);resizeCanvas();
window.addEventListener('wheel',e=>{if(e.ctrlKey){e.preventDefault();}}, {passive:false});
window.addEventListener('gesturestart', e=>{e.preventDefault();},{passive:false});
function styleHUD(){const hud=document.getElementById('hud');const st=document.getElementById('stamina');if(hud){hud.style.left=(12*uiScale)+'px';hud.style.top=(12*uiScale)+'px';hud.style.padding=(8*uiScale)+'px';hud.style.fontSize=Math.max(12,13*uiScale)+'px';hud.style.borderRadius=(6*uiScale)+'px';}if(st){st.style.left=(12*uiScale)+'px';st.style.bottom=(12*uiScale)+'px';st.style.padding=(6*uiScale)+'px';st.style.borderRadius=(8*uiScale)+'px';st.style.fontSize=Math.max(12,13*uiScale)+'px';st.style.minWidth=(250*uiScale)+'px';}}

// World, player, camera, input (similar to previous code) with minor adjustments
class World{constructor(w,h){this.w=w;this.h=h;this.tiles=new Uint8Array(w*h);this.objects=new Uint8Array(w*h);this.grassVariant=new Uint8Array(w*h);this.rockOffsetX=new Float32Array(w*h);this.rockOffsetY=new Float32Array(w*h);this.treeAnchor=new Uint8Array(w*h);this.seed=Math.floor(Math.random()*1e9);this.generate();}idx(x,y){return y*this.w+x;}inBounds(x,y){return x>=0&&y>=0&&x<this.w&&y<this.h;}getTile(x,y){if(!this.inBounds(x,y))return TILE_WATER;return this.tiles[this.idx(x,y)];}getObject(x,y){if(!this.inBounds(x,y))return OBJ_NONE;return this.objects[this.idx(x,y)];}setTile(x,y,v){if(!this.inBounds(x,y))return;this.tiles[this.idx(x,y)]=v;}setObject(x,y,v){if(!this.inBounds(x,y))return;this.objects[this.idx(x,y)]=v;}
generate(){const seed=this.seed;const biomeScale=90;const localScale=8;const biome=new Float32Array(this.w*this.h);for(let y=0;y<this.h;y++)for(let x=0;x<this.w;x++)biome[this.idx(x,y)]=octaveNoise(x,y,seed,5,biomeScale);const rnd=makeSeededRandom(seed+42);for(let y=0;y<this.h;y++){for(let x=0;x<this.w;x++){const i=this.idx(x,y);const b=biome[i];if(x<BARRIER_THICKNESS||y<BARRIER_THICKNESS||x>this.w-1-BARRIER_THICKNESS||y>this.h-1-BARRIER_THICKNESS){this.tiles[i]=TILE_WATER;continue;}if(b<0.35){const local=octaveNoise(x,y,seed+2000,3,localScale);this.tiles[i]=(local<0.5)?TILE_WATER:TILE_GRASS_BASE+Math.floor(octaveNoise(x,y,seed+7000,2,4)*GRASS_VARIANTS);} else if(b<0.67){this.tiles[i]=TILE_GRASS_BASE+Math.floor(octaveNoise(x,y,seed+3000,3,6)*GRASS_VARIANTS);} else {const local=octaveNoise(x,y,seed+4000,3,6);this.tiles[i]=(local<0.6)?TILE_DIRT:TILE_GRASS_BASE+Math.floor(octaveNoise(x,y,seed+8000,2,4)*GRASS_VARIANTS);}if(this.tiles[i]>=TILE_GRASS_BASE&&this.tiles[i]<TILE_GRASS_BASE+GRASS_VARIANTS)this.grassVariant[i]=this.tiles[i]-TILE_GRASS_BASE;}}const placeRnd=makeSeededRandom(seed+9999);for(let y=2;y<this.h-2;y++){for(let x=2;x<this.w-2;x++){const i=this.idx(x,y);const t=this.tiles[i];if(t===TILE_WATER)continue;const b=biome[i];let treeChance=0.01;if(b>=0.33&&b<0.67)treeChance=0.06;if(b>=0.67)treeChance=0.02;if(x<this.w-2&&y<this.h-2&&placeRnd()<treeChance){let ok=true;for(let yy=y;yy<y+2;yy++)for(let xx=x;xx<x+2;xx++){const idx2=this.idx(xx,yy);if(this.tiles[idx2]===TILE_WATER)ok=false;if(this.objects[idx2]!==OBJ_NONE)ok=false;}if(ok){for(let yy=y;yy<y+2;yy++)for(let xx=x;xx<x+2;xx++){this.objects[this.idx(xx,yy)]=OBJ_TREE;}this.treeAnchor[i]=1;continue;}}if(this.objects[i]===OBJ_NONE&&placeRnd()<0.025){this.objects[i]=OBJ_ROCK;const maxOff=TILE*0.36;this.rockOffsetX[i]=(placeRnd()*2-1)*maxOff;this.rockOffsetY[i]=(placeRnd()*2-1)*maxOff;}}}}
findSafeSpawn(){const cx=Math.floor(this.w/2),cy=Math.floor(this.h/2);const maxR=Math.max(this.w,this.h);for(let r=0;r<maxR;r++){for(let dy=-r;dy<=r;dy++){for(let dx=-r;dx<=r;dx++){const x=cx+dx,y=cy+dy;if(!this.inBounds(x,y))continue;const i=this.idx(x,y);if(this.tiles[i]===TILE_WATER)continue;if(this.objects[i]===OBJ_TREE)continue;let blocked=false;for(let yy=y-1;yy<=y+1;yy++)for(let xx=x-1;xx<=x+1;xx++){if(!this.inBounds(xx,yy)){blocked=true;break;}const idx2=this.idx(xx,yy);if(this.tiles[idx2]===TILE_WATER)blocked=true;if(this.objects[idx2]===OBJ_TREE)blocked=true;}if(blocked)continue;return{x:x*TILE+TILE/2,y:y*TILE+TILE/2};}}}return{x:cx*TILE+TILE/2,y:cy*TILE+TILE/2};}
}

// Draw functions (tree, rock) similar as before
function drawTreeLarge(ctx,cx,cy){ctx.save();ctx.translate(cx,cy);ctx.fillStyle='#6a4b2a';ctx.fillRect(-6,6,12,12);ctx.beginPath();ctx.ellipse(0,-4,26,20,0,0,Math.PI*2);ctx.fillStyle='#147a2c';ctx.fill();ctx.beginPath();ctx.ellipse(-8,-14,18,14,0,0,Math.PI*2);ctx.fillStyle='#1aa13a';ctx.fill();ctx.beginPath();ctx.ellipse(12,-12,14,10,0,0,Math.PI*2);ctx.fillStyle='#0f6b24';ctx.fill();ctx.restore();}
function drawRock(ctx,cx,cy){ctx.save();ctx.translate(cx,cy);ctx.beginPath();ctx.ellipse(0,0,6,5,0,0,Math.PI*2);ctx.fillStyle='#6b665b';ctx.fill();ctx.strokeStyle='rgba(0,0,0,0.25)';ctx.stroke();ctx.restore();}

// Player with square collisions
class Player{constructor(x,y){this.x=x;this.y=y;this.radius=10;this.baseSpeed=140;this.runMultiplier=1.9;this.angle=0;this.stamina=STAMINA_MAX;this.size=12;}
update(dt,input,world,camera,canvas){let vx=0,vy=0;if(input.isDown('w')||input.isDown('arrowup'))vy-=1;if(input.isDown('s')||input.isDown('arrowdown'))vy+=1;if(input.isDown('a')||input.isDown('arrowleft'))vx-=1;if(input.isDown('d')||input.isDown('arrowright'))vx+=1;const mag=Math.hypot(vx,vy);if(mag>0){vx/=mag;vy/=mag;}const wantRun=input.isDown('shift');const canRun=wantRun&&this.stamina>1;this.running=canRun;const speed=this.baseSpeed*(this.running?this.runMultiplier:1);
const nx=this.x+vx*speed*dt;const ny=this.y+vy*speed*dt;
const collides=(px,py)=>{const tx=Math.floor(px/TILE),ty=Math.floor(py/TILE);const tile=world.getTile(tx,ty);if(tile===TILE_WATER)return true;for(let ay=ty-1;ay<=ty+1;ay++){for(let ax=tx-1;ax<=tx+1;ax++){if(!world.inBounds(ax,ay))continue;const ai=world.idx(ax,ay);if(world.treeAnchor[ai]){const anchorX=ax,anchorY=ay,centerX=anchorX*TILE+TILE,centerY=anchorY*TILE+TILE;const ellips=[{dx:0,dy:-4,rx:26,ry:20},{dx:-8,dy:-14,rx:18,ry:14},{dx:12,dy:-12,rx:14,ry:10}];for(const e of ellips){const ex=centerX+e.dx,ey=centerY+e.dy;const nxn=(px-ex)/e.rx,nyn=(py-ey)/e.ry;if(nxn*nxn+nyn*nyn<=1)return true;}}}}return false;};if(!collides(nx,this.y))this.x=nx;if(!collides(this.x,ny))this.y=ny;
if(this.running&&(vx!==0||vy!==0)){this.stamina-=STAMINA_DRAIN_PER_SEC*dt;if(this.stamina<0)this.stamina=0;}else{this.stamina+=STAMINA_RECOVER_PER_SEC*dt;if(this.stamina>STAMINA_MAX)this.stamina=STAMINA_MAX;}
const sEl=document.getElementById('staminaVal');if(sEl)sEl.textContent=Math.round(this.stamina);
const mw=camera.screenToWorld(input.mouse.x,input.mouse.y,canvas);this.angle=Math.atan2(mw.y-this.y,mw.x-this.x);}
draw(ctx){ctx.save();ctx.translate(this.x,this.y);ctx.rotate(this.angle);ctx.fillStyle='#ffd8a8';ctx.fillRect(-this.size/2,-this.size/2,this.size,this.size);ctx.restore();}}

// Cursor block/tree outline
function drawCursorOutline(ctx,world,camera,input){const worldPos=camera.screenToWorld(input.mouse.x,input.mouse.y,canvas);const tx=Math.floor(worldPos.x/TILE),ty=Math.floor(worldPos.y/TILE);if(!world.inBounds(tx,ty))return;const obj=world.getObject(tx,ty);ctx.save();ctx.strokeStyle='yellow';ctx.lineWidth=2;ctx.globalAlpha=0.7;ctx.setLineDash([4,2]);
if(obj===OBJ_TREE){const cx=tx*TILE+TILE;const cy=ty*TILE+TILE;ctx.beginPath();ctx.ellipse(cx,cy-4,26,20,0,0,Math.PI*2);ctx.ellipse(cx-8,cy-14,18,14,0,0,Math.PI*2);ctx.ellipse(cx+12,cy-12,14,10,0,0,Math.PI*2);ctx.stroke();}else{const tile=world.getTile(tx,ty);if(tile!==TILE_WATER){ctx.strokeRect(tx*TILE,ty*TILE,TILE,TILE);}}ctx.restore();}

// Main init
const world=new World(MAP_W,MAP_H);const atlas=document.createElement('canvas');atlas.width=(GRASS_VARIANTS+2)*TILE;atlas.height=TILE;const spawn=world.findSafeSpawn();const player=new Player(spawn.x,spawn.y);const camera=new function(x=player.x,y=player.y,scale=CAMERA_DEFAULT){this.x=x;this.y=y;this.scale=scale;this.targetScale=scale;this.smooth=0.12;this.zoomSmooth=0.12;this.update=function(dt,tx,ty){this.x+= (tx-this.x)*this.smooth;this.y+= (ty-this.y)*this.smooth;this.scale+= (this.targetScale-this.scale)*this.zoomSmooth;};this.screenToWorld=function(sx,sy,canvas){return {x:(sx-canvas.width/2/ DPR)/this.scale+this.x,y:(sy-canvas.height/2/DPR)/this.scale+this.y};};}();
const input=new function(canvas){this.keys={};this.mouse={x:0,y:0,worldX:0,worldY:0};canvas.addEventListener('mousemove',e=>{const r=canvas.getBoundingClientRect();this.mouse.x=e.clientX-r.left;this.mouse.y=e.clientY-r.top;});canvas.addEventListener('wheel',e=>{e.preventDefault();if(!
