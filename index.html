<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>MineLite — 3D Block World (HTML + JS)</title>
  <style>
    html,body{height:100%;margin:0;background:#7ec0ff;}
    canvas{display:block}
    #ui{position:fixed;left:12px;bottom:12px;color:#111;font-family:Inter,Arial,Helvetica,sans-serif}
    #instructions{position:fixed;left:12px;top:12px;background:rgba(255,255,255,0.9);padding:10px;border-radius:8px;max-width:380px}
    #hotbar{display:flex;gap:6px;margin-top:8px}
    .slot{width:44px;height:44px;border-radius:6px;background:rgba(0,0,0,0.06);display:flex;align-items:center;justify-content:center;font-weight:700}
    #fps{position:fixed;right:12px;top:12px;background:rgba(255,255,255,0.9);padding:8px;border-radius:6px}
    #loading{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);background:#fff;padding:12px;border-radius:8px;box-shadow:0 6px 30px rgba(0,0,0,0.2)}
  </style>
</head>
<body>
  <div id="loading">Generating world — please wait...</div>
  <div id="instructions">
    <b>MineLite (demo)</b>
    <div>WASD move • Space jump • Click to break • Right-click to place • Scroll to change block</div>
    <div style="margin-top:6px;font-size:13px;color:#444">Click screen to lock cursor (pointer lock) and play.</div>
    <div id="hotbar"></div>
  </div>
  <div id="fps">FPS: <span id="fpsVal">0</span></div>
  <script src="https://unpkg.com/three@0.154.0/build/three.min.js"></script>
  <script>
  // ---------------------------
  // MineLite: single-file 3D block world
  // - uses THREE.js
  // - instanced meshes per block type for performance
  // - heightmap terrain via Perlin noise
  // - pointer-lock first-person controls
  // - place/break blocks
  // Notes: Designed to be compact & readable; extend as needed.
  // ---------------------------

  // Basic settings
  const WORLD_SIZE = { x: 64, z: 64, y: 32 }; // x,z plane and height y
  const CHUNK_SIZE = 16; // not used heavily, but for conceptual chunking
  const SEED = 1337;
  const BLOCK_TYPES = [
    { id: 0, name: 'air' },
    { id: 1, name: 'grass', color: 0x6dbf3f },
    { id: 2, name: 'dirt', color: 0x8b5222 },
    { id: 3, name: 'stone', color: 0x888888 },
    { id: 4, name: 'wood', color: 0x8b5a2b },
  ];
  let selectedBlock = 1; // grass default

  // Simple seeded Perlin noise implementation (2D)
  // small public-domain adaptation
  function buildPerlin(seed) {
    const p = new Uint8Array(512);
    const perm = new Uint8Array(256);
    for (let i = 0; i < 256; i++) perm[i] = i;
    // simple RNG
    let s = seed;
    function rnd() { s = (s * 1664525 + 1013904223) | 0; return (s >>> 0) / 4294967295; }
    for (let i = 255; i > 0; i--) {
      const j = Math.floor(rnd() * (i + 1));
      const tmp = perm[i]; perm[i] = perm[j]; perm[j] = tmp;
    }
    for (let i = 0; i < 512; i++) p[i] = perm[i & 255];
    function fade(t){return t*t*t*(t*(t*6-15)+10)}
    function lerp(a,b,t){return a+(b-a)*t}
    function grad(hash,x,y){
      const h = hash & 3; // 4 directions
      const u = h < 2 ? x : y;
      const v = h < 2 ? y : x;
      return ((h & 1) ? -u : u) + ((h & 2) ? -v : v);
    }
    return function(x,y){
      const X = Math.floor(x) & 255, Y = Math.floor(y) & 255;
      const xf = x - Math.floor(x), yf = y - Math.floor(y);
      const top = p[X+1 + p[Y+1]];
      const right = p[X+1 + p[Y]];
      const left = p[X + p[Y+1]];
      const bottom = p[X + p[Y]];
      const u = fade(xf), v = fade(yf);
      const aa = grad(p[X + p[Y]], xf, yf);
      const ab = grad(p[X + 1 + p[Y]], xf - 1, yf);
      const ba = grad(p[X + p[Y + 1]], xf, yf - 1);
      const bb = grad(p[X + 1 + p[Y + 1]], xf - 1, yf - 1);
      const x1 = lerp(aa, ab, u);
      const x2 = lerp(ba, bb, u);
      return lerp(x1, x2, v);
    }
  }

  // world grid (x,z,y) -> block id
  const world = new Uint8Array(WORLD_SIZE.x * WORLD_SIZE.y * WORLD_SIZE.z);
  function idx(x,y,z){return (x + z*WORLD_SIZE.x + y*WORLD_SIZE.x*WORLD_SIZE.z)}

  // generate heightmap terrain
  const noise = buildPerlin(SEED);
  function generateWorld(){
    for (let x=0;x<WORLD_SIZE.x;x++){
      for (let z=0;z<WORLD_SIZE.z;z++){
        const nx = x / 20, nz = z / 20;
        const e = (noise(nx*1.0, nz*1.0) * 0.7 + noise(nx*2.0, nz*2.0)*0.2 + noise(nx*4.0,nz*4.0)*0.1);
        const height = Math.floor((e + 1) * 6) + 8; // between ~2 and 20
        for (let y=0;y<WORLD_SIZE.y;y++){
          let block = 0;
          if (y <= height - 1){
            if (y === height - 1) block = 1; // grass on top
            else if (y > height - 5) block = 2; // dirt
            else block = 3; // stone deeper
          }
          // small trees randomly
          world[idx(x,y,z)] = block;
        }
        // add trees
        if (Math.random() < 0.04){
          const top = Math.floor((noise(nx*3,nz*3)+1)*5)+9;
          // trunk
          for (let t=top-3;t<=top;t++) setBlock(x,t,z,4);
          // leaves cube
          for (let lx=-2;lx<=2;lx++) for (let lz=-2;lz<=2;lz++) for (let ly=0;ly<=2;ly++){
            const ax = x+lx, az = z+lz, ay = top+ly;
            if (inBounds(ax,ay,az) && Math.abs(lx)+Math.abs(lz)+ly<5) setBlock(ax,ay,az,2); // simple leaves = dirt color (placeholder)
          }
        }
      }
    }
  }
  function inBounds(x,y,z){return x>=0&&y>=0&&z>=0&&x<WORLD_SIZE.x&&y<WORLD_SIZE.y&&z<WORLD_SIZE.z}
  function getBlock(x,y,z){if(!inBounds(x,y,z)) return 0; return world[idx(x,y,z)];}
  function setBlock(x,y,z,id){if(!inBounds(x,y,z)) return; world[idx(x,y,z)] = id}

  // THREE.js scene setup
  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(70, innerWidth/innerHeight, 0.1, 1000);
  camera.position.set(WORLD_SIZE.x/2, 20, WORLD_SIZE.z/2 + 4);
  const renderer = new THREE.WebGLRenderer({antialias:true});
  renderer.setSize(innerWidth, innerHeight);
  renderer.setClearColor(0x7ec0ff);
  document.body.appendChild(renderer.domElement);

  // lighting
  const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 0.9);
  scene.add(hemi);
  const dir = new THREE.DirectionalLight(0xffffff, 0.6);
  dir.position.set(-5, 10, -2);
  scene.add(dir);

  // Instanced meshes per block type (except air)
  const blockMeshes = {}; // id -> {mesh, matrices}
  const boxGeom = new THREE.BoxGeometry(1,1,1);
  for (const b of BLOCK_TYPES){
    if (b.id===0) continue;
    const mat = new THREE.MeshStandardMaterial({color: b.color});
    const mesh = new THREE.InstancedMesh(boxGeom, mat, WORLD_SIZE.x*WORLD_SIZE.y*WORLD_SIZE.z);
    mesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
    mesh.count = 0;
    blockMeshes[b.id] = {mesh, color:b.color};
    scene.add(mesh);
  }

  // Build meshes from world array: simple—create transforms for each block type
  function rebuildMeshes(){
    // reset counts
    for (const id in blockMeshes) blockMeshes[id].mesh.count = 0;
    let tempMatrix = new THREE.Matrix4();
    let offset = new THREE.Vector3();
    for (let x=0;x<WORLD_SIZE.x;x++){
      for (let z=0;z<WORLD_SIZE.z;z++){
        for (let y=0;y<WORLD_SIZE.y;y++){
          const b = getBlock(x,y,z);
          if (b===0) continue;
          const bm = blockMeshes[b];
          const i = bm.mesh.count;
          offset.set(x - WORLD_SIZE.x/2, y, z - WORLD_SIZE.z/2);
          tempMatrix.makeTranslation(offset.x+0.5, offset.y+0.5, offset.z+0.5);
          bm.mesh.setMatrixAt(i, tempMatrix);
          bm.mesh.count = i+1;
        }
      }
    }
    for (const id in blockMeshes){
      blockMeshes[id].mesh.instanceMatrix.needsUpdate = true;
      blockMeshes[id].mesh.visible = blockMeshes[id].mesh.count>0;
    }
  }

  // generate and build
  generateWorld();
  rebuildMeshes();

  // crosshair
  const cross = document.createElement('div');
  cross.style.position='fixed'; cross.style.left='50%'; cross.style.top='50%'; cross.style.transform='translate(-50%,-50%)';
  cross.style.width='6px'; cross.style.height='6px'; cross.style.borderRadius='50%'; cross.style.background='rgba(0,0,0,0.6)';
  document.body.appendChild(cross);

  // pointer lock controls (simple)
  const move = {forward:0,back:0,left:0,right:0,jump:0};
  let velocity = new THREE.Vector3();
  let canJump = false;
  const pitch = new THREE.Object3D();
  const yaw = new THREE.Object3D();
  yaw.add(pitch);
  pitch.add(camera);
  yaw.position.copy(camera.position);
  scene.add(yaw);

  let prevTime = performance.now();
  const onKeyDown = (e)=>{
    switch(e.code){
      case 'KeyW': move.forward=1; break;
      case 'KeyS': move.back=1; break;
      case 'KeyA': move.left=1; break;
      case 'KeyD': move.right=1; break;
      case 'Space': if(canJump){velocity.y = 7; canJump=false;} break;
    }
  };
  const onKeyUp = (e)=>{
    switch(e.code){
      case 'KeyW': move.forward=0; break;
      case 'KeyS': move.back=0; break;
      case 'KeyA': move.left=0; break;
      case 'KeyD': move.right=0; break;
    }
  };
  window.addEventListener('keydown', onKeyDown);
  window.addEventListener('keyup', onKeyUp);

  // pointer lock mouse look
  renderer.domElement.addEventListener('click', ()=>{
    renderer.domElement.requestPointerLock?.();
  });
  function onPointerMove(e){
    if(document.pointerLockElement !== renderer.domElement) return;
    const movementX = e.movementX || 0;
    const movementY = e.movementY || 0;
    yaw.rotation.y -= movementX * 0.0025;
    pitch.rotation.x -= movementY * 0.0025;
    pitch.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, pitch.rotation.x));
  }
  document.addEventListener('pointermove', onPointerMove);

  // raycaster for interactions
  const raycaster = new THREE.Raycaster();
  raycaster.far = 8; // reach

  // convert camera forward ray to world grid pos
  function getTargetBlock(){
    raycaster.setFromCamera(new THREE.Vector2(0,0), camera);
    // We'll cast against the instanced meshes by computing intersections per block type
    // Simpler: step along the ray in small increments and check grid occupancy
    const origin = new THREE.Vector3();
    origin.copy(camera.position);
    const dir = new THREE.Vector3();
    camera.getWorldDirection(dir);
    const step = 0.2; const maxSteps = Math.floor(raycaster.far / step);
    let lastEmpty = null;
    for (let i=0;i<maxSteps;i++){
      const p = origin.clone().addScaledVector(dir, i*step);
      const gx = Math.floor(p.x + WORLD_SIZE.x/2);
      const gy = Math.floor(p.y);
      const gz = Math.floor(p.z + WORLD_SIZE.z/2);
      if(!inBounds(gx,gy,gz)) continue;
      const b = getBlock(gx,gy,gz);
      if(b!==0){
        return {hit:true, blockPos:[gx,gy,gz], placePos:lastEmpty};
      } else {
        lastEmpty = [gx,gy,gz];
      }
    }
    return {hit:false, blockPos:null, placePos:lastEmpty};
  }

  // mouse clicks: left = break, right = place
  window.addEventListener('mousedown', (e)=>{
    if(document.pointerLockElement !== renderer.domElement) return;
    const t = getTargetBlock();
    if(e.button===0){ // left click break
      if(t.hit){ setBlock(...t.blockPos, 0); rebuildMeshes(); }
    } else if(e.button===2){ // right click place
      if(t.placePos){ const [x,y,z]=t.placePos; setBlock(x,y,z, selectedBlock); rebuildMeshes(); }
    }
  });
  // prevent context menu on right click
  window.addEventListener('contextmenu', e=>e.preventDefault());

  // hotbar UI
  const hotbar = document.getElementById('hotbar');
  function buildHotbar(){
    while(hotbar.firstChild) hotbar.removeChild(hotbar.firstChild);
    for (let i=1;i<BLOCK_TYPES.length;i++){
      const s = document.createElement('div'); s.className='slot'; s.textContent = BLOCK_TYPES[i].name[0].toUpperCase();
      s.title = BLOCK_TYPES[i].name;
      s.onclick = ()=>{ selectedBlock = BLOCK_TYPES[i].id; updateHotbar(); }
      hotbar.appendChild(s);
    }
    updateHotbar();
  }
  function updateHotbar(){
    Array.from(hotbar.children).forEach((c,idx)=>{
      const id = idx+1;
      c.style.outline = (selectedBlock===id)?'3px solid rgba(0,0,0,0.6)':'none';
    });
  }
  buildHotbar();

  // change selected by wheel
  window.addEventListener('wheel', (e)=>{
    if(e.deltaY>0) selectedBlock = Math.min(selectedBlock+1, BLOCK_TYPES.length-1);
    else selectedBlock = Math.max(1, selectedBlock-1);
    updateHotbar();
  }, {passive:true});

  // basic collision: check block at feet
  function isOnGround(pos){
    const fx = Math.floor(pos.x + WORLD_SIZE.x/2);
    const fy = Math.floor(pos.y - 0.1);
    const fz = Math.floor(pos.z + WORLD_SIZE.z/2);
    return getBlock(fx, fy, fz) !== 0;
  }

  // resize handling
  window.addEventListener('resize', ()=>{camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix(); renderer.setSize(innerWidth, innerHeight);});

  // FPS counter
  const fpsEl = document.getElementById('fpsVal'); let fpsFrameCount=0, fpsLast=performance.now();

  // main loop
  function animate(){
    const time = performance.now();
    const delta = Math.min(0.05, (time - prevTime)/1000);
    prevTime = time;

    // movement
    const speed = 7.5;
    const forward = move.forward - move.back;
    const strafe = move.right - move.left;
    const dir = new THREE.Vector3();
    yaw.getWorldDirection(dir);
    dir.y = 0; dir.normalize();
    const rightVec = new THREE.Vector3(); rightVec.crossVectors(new THREE.Vector3(0,1,0), dir).normalize();
    const acceleration = new THREE.Vector3();
    acceleration.addScaledVector(dir, forward * speed);
    acceleration.addScaledVector(rightVec, strafe * speed);

    // apply horizontal velocity
    velocity.x += (acceleration.x - velocity.x) * 10 * delta;
    velocity.z += (acceleration.z - velocity.z) * 10 * delta;

    // gravity
    velocity.y -= 20 * delta;

    // position update
    yaw.position.x += velocity.x * delta;
    yaw.position.y += velocity.y * delta;
    yaw.position.z += velocity.z * delta;

    // floor collision
    if (yaw.position.y < 1.2) {
      velocity.y = 0; yaw.position.y = 1.2; canJump = true;
    }

    // update camera world position
    camera.position.copy(yaw.position);

    renderer.render(scene, camera);

    // fps
    fpsFrameCount++;
    if (time - fpsLast > 500){ fpsEl.textContent = Math.round((fpsFrameCount*1000)/(time-fpsLast)); fpsLast = time; fpsFrameCount=0; }

    requestAnimationFrame(animate);
  }

  // initial camera height and start
  camera.position.set(0,20,0);
  yaw.position.copy(camera.position);

  // done loading
  document.getElementById('loading').remove();
  animate();
  </script>
</body>
</html>
