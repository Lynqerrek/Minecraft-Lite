<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>MineLite — Player1Up mask collisions (day/night) + Clouds</title>
  <style>
    html,body{height:100%;margin:0;background:#0b1220;color:#ddd;font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;overflow:hidden}
    canvas{display:block}
    .hud{position:fixed;left:12px;top:12px;color:#fff;background:rgba(0,0,0,.28);padding:8px;border-radius:6px;font-size:13px;pointer-events:none;transform-origin:0 0}
    .title{font-weight:700;margin-bottom:6px}
    .hint{opacity:.9}
    .stamina{position:fixed;left:12px;bottom:12px;padding:6px;background:rgba(0,0,0,0.32);border-radius:8px;color:#fff;font-family:monospace;pointer-events:none;transform-origin:0 0}
    #loadingOverlay { position:fixed; inset:0; display:flex; align-items:center; justify-content:center; flex-direction:column; background:linear-gradient(180deg, rgba(6,8,12,0.98) 0%, rgba(4,6,10,0.98) 100%); z-index:9999; transition:opacity .45s ease, visibility .45s ease; }
    #loadingOverlay.hidden { opacity:0; visibility:hidden; pointer-events:none; }
    #loadingBox { text-align:center; color:#fff; transform:translateY(0); }
    #loadingBox img { max-width:360px; width:40vmin; height:auto; image-rendering:pixelated; display:block; margin:0 auto 18px; }
    #progressWrap { width: min(520px, 80vw); background: rgba(255,255,255,0.06); border-radius:10px; padding:8px; box-sizing:border-box; }
    #progressBar { width:100%; height:12px; background:rgba(0,0,0,0.24); border-radius:8px; overflow:hidden; }
    #progressBarInner { width:0%; height:100%; background: linear-gradient(90deg,#9be15d,#27ae60); transition:width .18s linear; }
  </style>
</head>
<body>
  <canvas id="game"></canvas>

  <div id="loadingOverlay">
    <div id="loadingBox">
      <img id="loadingImg" src="Loading.png" alt="Loading">
      <div id="progressWrap">
        <div id="progressBar"><div id="progressBarInner"></div></div>
        <div id="progressText">Loading — 0%</div>
      </div>
    </div>
  </div>

  <div id="hud" class="hud">
    <div class="title">MineLite</div>
    <div><strong>Controls</strong></div>
    <div class="hint">WASD / Arrows — move</div>
    <div class="hint">Hold Shift — run (uses stamina)</div>
    <div class="hint">Mouse — aim (not used for facing)</div>
    <div class="hint">Scroll — zoom (Ctrl+Scroll disabled)</div>
    <div id="timeDisplay" class="hint" style="margin-top:8px;font-weight:600">Time: --:--</div>
  </div>
  <div id="stamina" class="stamina">Stamina: <span id="staminaVal">100</span></div>

<script>
// ========== CONFIG ==========
// (kept your original constants unchanged)
const TILE = 44;
const MAP_W = 640, MAP_H = 640;
let DPR = window.devicePixelRatio || 1;

const GRASS_VARIANTS = 4;
const TILE_GRASS_BASE = 0;
const TILE_DIRT = GRASS_VARIANTS;
const TILE_WATER = GRASS_VARIANTS+1;
const OBJ_NONE = 0, OBJ_ROCK = 1, OBJ_TREE = 2;
const BARRIER_THICKNESS = Math.max(10, Math.floor(Math.min(MAP_W, MAP_H) * 0.12)) * 2;

const ZOOM_IN_MAX = 5;
const ZOOM_OUT_MIN = ZOOM_IN_MAX / 2;
const CAMERA_DEFAULT = (ZOOM_IN_MAX + ZOOM_OUT_MIN) / 1.6;

// --- PLAYER SIZE (2x bigger)
const PLAYER_WORLD_SIZE = TILE * 0.85; // set to TILE*1.0 (was TILE*0.5) => 2x bigger

// --- animation timings
const FRAME_INTERVAL_BASE = 0.35; // seconds per frame normally

// stamina/sprint
const STAMINA_MAX = 100;
const STAMINA_DRAIN_PER_SEC = 12.5;
const STAMINA_RECOVER_PER_SEC = 5;

// ========== DAY / NIGHT CONFIG ==========
// ... (rest of your original code unchanged until assets list)

let timeOfDay = 22.0; // hours (0-24) — start at night
const DAY_LENGTH_SECONDS = 180; // full day in seconds (adjustable)
let stars = [];

// ========== HELPERS ==========
function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
function lerp(a,b,t){ return a + (b-a)*t; }
function makeSeededRandom(seed){ let s = seed>>>0; return function(){ s = (s + 0x6D2B79F5) | 0; let t = Math.imul(s ^ s>>>15, 1 | s); t = (t + Math.imul(t ^ t>>>7, 61 | t)) ^ t; return ((t ^ t>>>14) >>> 0) / 4294967296; } }
function smoothstep(a){ return a*a*(3-2*a); }
function valueNoise2D(x,y,seed){ const xf=Math.floor(x), yf=Math.floor(y); const rx=x-xf, ry=y-yf; const u=smoothstep(rx), v=smoothstep(ry); const r00 = makeSeededRandom(((xf*73856093) ^ (yf*19349663) ^ seed)>>>0)(); const r10 = makeSeededRandom((((xf+1)*73856093) ^ (yf*19349663) ^ seed)>>>0)(); const r01 = makeSeededRandom(((xf*73856093) ^ ((yf+1)*19349663) ^ seed)>>>0)(); const r11 = makeSeededRandom((((xf+1)*73856093) ^ ((yf+1)*19349663) ^ seed)>>>0)(); const xa = r00*(1-u) + r10*u; const xb = r01*(1-u) + r11*u; return xa*(1-v) + xb*v; }
function octaveNoise(x,y,seed,oct=4,scale=1){ let amp=1,freq=1,sum=0,tot=0; for(let i=0;i<oct;i++){ sum += valueNoise2D(x*freq/scale, y*freq/scale, seed + i*1000) * amp; tot += amp; amp *= 0.5; freq *= 2; } return sum/tot; }

// ========== CANVAS & UI ==========
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
let canvasW=0, canvasH=0, uiScale = DPR;

function resizeCanvas(){
  DPR = window.devicePixelRatio || 1;
  canvasW = Math.max(320, window.innerWidth);
  canvasH = Math.max(240, window.innerHeight);
  canvas.style.width = canvasW + 'px';
  canvas.style.height = canvasH + 'px';
  canvas.width = Math.floor(canvasW * DPR);
  canvas.height = Math.floor(canvasH * DPR);
  canvas.style.imageRendering = 'pixelated';
  const baselineW = 1920, baselineH = 1080;
  const ratio = Math.min(canvasW / baselineW, canvasH / baselineH);
  uiScale = Math.min(2.0, Math.max(0.75, ratio * DPR));
  styleHUD();
  ctx.imageSmoothingEnabled = false;
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();
function styleHUD(){ const hud=document.getElementById('hud'), st=document.getElementById('stamina'); if(hud) hud.style.transform=`scale(${uiScale})`; if(st) st.style.transform=`scale(${uiScale})`; }

// ========== PIXEL MASK BUILDER ==========
function buildMaskFromImage(img){
  if(!img || !img.complete) return null;
  const w = img.width, h = img.height;
  const c = document.createElement('canvas');
  c.width = w; c.height = h;
  const cc = c.getContext('2d');
  cc.imageSmoothingEnabled = false;
  cc.clearRect(0,0,w,h);
  cc.drawImage(img, 0, 0, w, h);
  const id = cc.getImageData(0,0,w,h).data;
  const mask = new Uint8Array(w*h);
  for(let y=0;y<h;y++){
    for(let x=0;x<w;x++){
      const a = id[(y*w + x)*4 + 3];
      mask[y*w + x] = a > 128 ? 1 : 0;
    }
  }
  return { mask, w, h };
}

// ========== TILE ATLAS ==========
function createPixelatedTileAtlas(blockSize = 8){
  const off = document.createElement('canvas');
  off.width = (GRASS_VARIANTS + 2) * TILE;
  off.height = TILE;
  const oc = off.getContext('2d');
  oc.imageSmoothingEnabled = true;

  const grassColors=[['#7cc85b','#4fa043'],['#6fb23a','#4b8d2e'],['#8bdc66','#52a544'],['#5fb03a','#3f7b2a']];
  for(let v=0; v<GRASS_VARIANTS; v++){
    const gx = v*TILE;
    const g = oc.createLinearGradient(gx,0,gx+TILE,TILE);
    g.addColorStop(0, grassColors[v][0]); g.addColorStop(1, grassColors[v][1]);
    oc.fillStyle = g; oc.fillRect(gx,0,TILE,TILE);
    for(let i=0;i<40;i++){ oc.fillStyle=`rgba(0,0,0,${Math.random()*0.04})`; oc.fillRect(gx+Math.random()*TILE, Math.random()*TILE, 1,1); }
  }
  const dx = GRASS_VARIANTS * TILE;
  const dg = oc.createLinearGradient(dx,0,dx+TILE,TILE); dg.addColorStop(0,'#9f6b3a'); dg.addColorStop(1,'#7a4b2a'); oc.fillStyle=dg; oc.fillRect(dx,0,TILE,TILE); for(let i=0;i<30;i++){ oc.fillStyle=`rgba(0,0,0,${Math.random()*0.05})`; oc.fillRect(dx+Math.random()*TILE, Math.random()*TILE, 1,1); }
  const wx=(GRASS_VARIANTS+1)*TILE; const wg=oc.createLinearGradient(wx,0,wx+TILE,TILE); wg.addColorStop(0,'#3aa9df'); wg.addColorStop(1,'#1f6fa8'); oc.fillStyle=wg; oc.fillRect(wx,0,TILE,TILE);
  oc.globalAlpha=0.08; for(let i=0;i<3;i++){ oc.fillRect(wx + i*6 + 2, 6 + i*3, TILE-8, 2); } oc.globalAlpha=1;

  const tileSmall = Math.max(1, Math.floor(TILE / blockSize));
  const small = document.createElement('canvas');
  small.width = (GRASS_VARIANTS + 2) * tileSmall;
  small.height = tileSmall;
  const sc = small.getContext('2d');
  sc.imageSmoothingEnabled = false;
  sc.drawImage(off, 0, 0, off.width, off.height, 0, 0, small.width, small.height);
  small.__tileSmall = tileSmall;
  return small;
}

// ========== WORLD ==========
class World {
  constructor(w,h){
    this.w=w; this.h=h;
    this.tiles = new Uint8Array(w*h);
    this.objects = new Uint8Array(w*h);
    this.grassVariant = new Uint8Array(w*h);
    this.rockOffsetX = new Float32Array(w*h);
    this.rockOffsetY = new Float32Array(w*h);
    this.rockVariant = new Uint8Array(w*h);
    this.rockScale = new Float32Array(w*h);
    this.treeAnchor = new Uint8Array(w*h);
    this.trees = [];
    this.seed = Math.floor(Math.random()*1e9);
    this.generate();
  }
  idx(x,y){ return y*this.w + x; }
  inBounds(x,y){ return x>=0 && y>=0 && x<this.w && y<this.h; }
  getTile(x,y){ if(!this.inBounds(x,y)) return TILE_WATER; return this.tiles[this.idx(x,y)]; }
  getObject(x,y){ if(!this.inBounds(x,y)) return OBJ_NONE; return this.objects[this.idx(x,y)]; }

  generate(){
    this.trees.length = 0;
    const seed = this.seed; const biomeScale = 90; const localScale = 8;
    const biome = new Float32Array(this.w*this.h);
    for(let y=0;y<this.h;y++) for(let x=0;x<this.w;x++) biome[this.idx(x,y)] = octaveNoise(x,y,seed,5,biomeScale);
    const placeRnd = makeSeededRandom(seed+9999);
    for(let y=0;y<this.h;y++){
      for(let x=0;x<this.w;x++){
        const i=this.idx(x,y); const b=biome[i];
        if(x < BARRIER_THICKNESS || y < BARRIER_THICKNESS || x > this.w-1-BARRIER_THICKNESS || y > this.h-1-BARRIER_THICKNESS){ this.tiles[i] = TILE_WATER; continue; }
        if(b < 0.35){ const local = octaveNoise(x,y,seed+2000,3,localScale); this.tiles[i] = (local < 0.5) ? TILE_WATER : TILE_GRASS_BASE + Math.floor(octaveNoise(x,y,seed+7000,2,4)*GRASS_VARIANTS); }
        else if(b < 0.67){ this.tiles[i] = TILE_GRASS_BASE + Math.floor(octaveNoise(x,y,seed+3000,3,6)*GRASS_VARIANTS); }
        else { const local = octaveNoise(x,y,seed+4000,3,6); this.tiles[i] = (local < 0.6) ? TILE_DIRT : TILE_GRASS_BASE + Math.floor(octaveNoise(x,y,seed+8000,2,4)*GRASS_VARIANTS); }
        if(this.tiles[i] >= TILE_GRASS_BASE && this.tiles[i] < TILE_GRASS_BASE+GRASS_VARIANTS) this.grassVariant[i] = this.tiles[i] - TILE_GRASS_BASE;
      }
    }

    for(let y=2; y<this.h-2; y++){
      for(let x=2; x<this.w-2; x++){
        const i=this.idx(x,y); const t=this.tiles[i]; if(t === TILE_WATER) continue;
        const b = biome[i]; let treeChance = 0.01; if(b >= 0.33 && b < 0.67) treeChance = 0.06; if(b >= 0.67) treeChance = 0.02;
        if(x < this.w-2 && y < this.h-2 && placeRnd() < treeChance){
          let ok=true;
          for(let yy=y; yy<y+2; yy++) for(let xx=x; xx<x+2; xx++){
            const idx2=this.idx(xx,yy);
            if(this.tiles[idx2] === TILE_WATER) ok=false;
            if(this.objects[idx2] !== OBJ_NONE) ok=false;
          }
          if(ok){
            for(let yy=y; yy<y+2; yy++) for(let xx=x; xx<x+2; xx++){
              this.objects[this.idx(xx,yy)] = OBJ_TREE;
            }
            this.treeAnchor[i] = 1;
            const cx = x*TILE + TILE; const cy = y*TILE + TILE;
            this.trees.push({anchorX:x, anchorY:y, cx:cx, cy:cy});
            continue;
          }
        }
        if(this.objects[i] === OBJ_NONE && placeRnd() < 0.025){
          this.objects[i] = OBJ_ROCK;
          const maxOff = TILE*0.36;
          this.rockOffsetX[i] = (placeRnd()*2-1)*maxOff;
          this.rockOffsetY[i] = (placeRnd()*2-1)*maxOff;
          this.rockVariant[i] = Math.floor(placeRnd()*3);
          this.rockScale[i] = 0.6 + placeRnd() * 0.9;
        }
      }
    }
  }

  findSafeSpawn(){ const cx = Math.floor(this.w/2), cy = Math.floor(this.h/2); const maxR = Math.max(this.w,this.h); for(let r=0;r<maxR;r++){ for(let dy=-r; dy<=r; dy++){ for(let dx=-r; dx<=r; dx++){ const x = cx + dx, y = cy + dy; if(!this.inBounds(x,y)) continue; const i=this.idx(x,y); if(this.tiles[i] === TILE_WATER) continue; if(this.objects[i] === OBJ_TREE) continue; let blocked=false; for(let yy=y-1; yy<=y+1; yy++) for(let xx=x-1; xx<=x+1; xx++){ if(!this.inBounds(xx,yy)){ blocked=true; break; } const idx2=this.idx(xx,yy); if(this.tiles[idx2] === TILE_WATER) blocked=true; if(this.objects[idx2] === OBJ_TREE) blocked=true; } if(blocked) continue; return {x: x*TILE + TILE/2, y: y*TILE + TILE/2}; } } } return {x: cx*TILE + TILE/2, y: cy*TILE + TILE/2}; }

  draw(ctx, camera, canvas, atlasSmall, treeImg, treeWorldSize, rockImgs, rockBaseWorldSize){
    const left = Math.max(0, Math.floor((camera.x - (canvasW/2)/camera.scale)/TILE) - 1);
    const right = Math.min(this.w-1, Math.ceil((camera.x + (canvasW/2)/camera.scale)/TILE) + 1);
    const top = Math.max(0, Math.floor((camera.y - (canvasH/2)/camera.scale)/TILE) -1);
    const bottom = Math.min(this.h-1, Math.ceil((camera.y + (canvasH/2)/camera.scale)/TILE) +1);

    const tileSmall = atlasSmall.__tileSmall || Math.max(1, Math.floor(TILE/8));
    for(let yy=top; yy<=bottom; yy++){
      for(let xx=left; xx<=right; xx++){
        const i=this.idx(xx,yy); const tile=this.tiles[i];
        const sx = (tile >= TILE_GRASS_BASE && tile < TILE_GRASS_BASE+GRASS_VARIANTS) ? (this.grassVariant[i] * tileSmall) : ((tile === TILE_DIRT) ? (GRASS_VARIANTS * tileSmall) : ((GRASS_VARIANTS+1) * tileSmall));
        ctx.imageSmoothingEnabled = false;
        ctx.drawImage(atlasSmall, sx, 0, tileSmall, tileSmall, xx*TILE, yy*TILE, TILE, TILE);
      }
    }

    if(rockImgs && rockImgs.length > 0){
      ctx.imageSmoothingEnabled = false;
      for(let yy=top; yy<=bottom; yy++){
        for(let xx=left; xx<=right; xx++){
          const i = this.idx(xx,yy); const o = this.objects[i];
          if(o === OBJ_ROCK){
            const cx = xx*TILE + TILE/2 + this.rockOffsetX[i];
            const cy = yy*TILE + TILE/2 + this.rockOffsetY[i];
            const variant = this.rockVariant[i] || 0;
            const scale = this.rockScale[i] || 1.0;
            const img = rockImgs[variant];
            if(img && img.complete){
              const worldSize = rockBaseWorldSize * scale;
              ctx.drawImage(img, cx - worldSize/2, cy - worldSize/2, worldSize, worldSize);
            } else {
              drawRock(ctx, xx*TILE + TILE/2, yy*TILE + TILE/2);
            }
          }
        }
      }
    } else {
      for(let yy=top; yy<=bottom; yy++){
        for(let xx=left; xx<=right; xx++){
          const i = this.idx(xx,yy); const o = this.objects[i];
          if(o === OBJ_ROCK){ const cx = xx*TILE + TILE/2 + this.rockOffsetX[i]; const cy = yy*TILE + TILE/2 + this.rockOffsetY[i]; drawRock(ctx, cx, cy); }
        }
      }
    }

    if(treeImg && treeImg.complete){
      ctx.imageSmoothingEnabled = false;
      for(const t of this.trees){
        const cx = t.cx, cy = t.cy;
        ctx.drawImage(treeImg, cx - treeWorldSize/2, cy - treeWorldSize/2, treeWorldSize, treeWorldSize);
      }
    }
  }
}
function drawRock(ctx,cx,cy){ ctx.save(); ctx.translate(cx,cy); ctx.beginPath(); ctx.ellipse(0,0,6,5,0,0,Math.PI*2); ctx.fillStyle='#6b665b'; ctx.fill(); ctx.strokeStyle='rgba(0,0,0,0.25)'; ctx.stroke(); ctx.restore(); }

// ========== INPUT & CAMERA ==========
class Input{ constructor(canvas){ this.keys={}; this.mouse={x:0,worldX:0,y:0,worldY:0}; canvas.addEventListener('mousemove', e=>{ const r=canvas.getBoundingClientRect(); this.mouse.x = e.clientX - r.left; this.mouse.y = e.clientY - r.top; }); canvas.addEventListener('wheel', e=>{ e.preventDefault(); if(!e.ctrlKey) camera.targetScale = clamp(camera.targetScale * (1 - e.deltaY * 0.0012), ZOOM_OUT_MIN, ZOOM_IN_MAX); }, {passive:false}); window.addEventListener('keydown', e=>{ this.keys[e.key.toLowerCase()] = true; }); window.addEventListener('keyup', e=>{ this.keys[e.key.toLowerCase()] = false; }); } isDown(k){ return !!this.keys[k.toLowerCase()]; } }
class Camera{ constructor(x=0,y=0,scale=CAMERA_DEFAULT){ this.x=x; this.y=y; this.scale=scale; this.targetScale=scale; this.smooth=0.12; this.zoomSmooth=0.12; } update(dt,tx,ty){ this.x = lerp(this.x, tx, this.smooth); this.y = lerp(this.y, ty, this.smooth); this.scale = lerp(this.scale, this.targetScale, this.zoomSmooth); } screenToWorld(sx,sy){ const wx = (sx - canvasW/2)/this.scale + this.x; const wy = (sy - canvasH/2)/this.scale + this.y; return {x:wx,y:wy}; } }

// ========== TREE MASK ==========
let treeMask = null; let treeImgW = 0, treeImgH = 0;
let TREE_WORLD_SIZE = TILE * 1.75;
let TREE_RADIUS = TREE_WORLD_SIZE * 0.45;
function buildTreeMaskFromImage(treeImg){
  treeImgW = treeImg.width; treeImgH = treeImg.height;
  const c = document.createElement('canvas'); c.width = treeImgW; c.height = treeImgH; const cc = c.getContext('2d'); cc.imageSmoothingEnabled=false; cc.clearRect(0,0,c.width,c.height); cc.drawImage(treeImg,0,0);
  const id = cc.getImageData(0,0,c.width,c.height).data;
  treeMask = new Uint8Array(treeImgW * treeImgH);
  for(let y=0;y<treeImgH;y++){ for(let x=0;x<treeImgW;x++){ const idx=(y*c.width+x)*4+3; treeMask[y*c.width+x] = id[idx] > 128 ? 1 : 0; } }
  console.log('Tree mask built', treeImgW+'x'+treeImgH);
}

// ========== PARTICLES ==========
class Particle { constructor(){ this.alive = false; } init(x,y,vx,vy,life,color){ this.x=x; this.y=y; this.vx=vx; this.vy=vy; this.life=life; this.maxLife=life; this.color=color; this.alive=true; } update(dt){ if(!this.alive) return; this.life -= dt; if(this.life <= 0){ this.alive = false; return; } this.vy += 80 * dt; this.x += this.vx * dt; this.y += this.vy * dt; } draw(ctx){ if(!this.alive) return; ctx.globalAlpha = 1; ctx.fillStyle = this.color; ctx.fillRect(Math.round(this.x), Math.round(this.y), 1, 1); ctx.globalAlpha = 1; } }
class ParticleSystem { constructor(maxParticles=55){ this.max = maxParticles; this.pool = new Array(this.max); for(let i=0;i<this.max;i++) this.pool[i] = new Particle(); } spawn(x,y,vx,vy,life,color){ for(let i=0;i<this.max;i++){ const p=this.pool[i]; if(!p.alive){ p.init(x,y,vx,vy,life,color); return; } } let bestIdx=0, bestLife=1e9; for(let i=0;i<this.max;i++){ if(this.pool[i].life < bestLife){ bestLife = this.pool[i].life; bestIdx = i; } } this.pool[bestIdx].init(x,y,vx,vy,life,color); } update(dt){ for(const p of this.pool) if(p.alive) p.update(dt); } draw(ctx){ for(const p of this.pool) if(p.alive) p.draw(ctx); } }

// ========== PLAYER (uses Player1Up mask for collisions) ==========
class Player {
  constructor(x,y){
    this.x = x; this.y = y;
    this.baseSpeed = 100; this.runMultiplier = 1.8;
    this.stamina = STAMINA_MAX; this.running=false; this.exhausted=false;
    this.worldSize = PLAYER_WORLD_SIZE;
    this.radius = Math.max(4, this.worldSize * 0.45);
    this._stepAcc = 0;

    // animation frames (we use right frames and mirror to left)
    this.animMap = { down: [null,null], up: [null,null], right: [null,null] };
    this.idleImg = null;

    // animation state
    this.direction = 'down';
    this.lastDirection = 'down';
    this.frameIndex = 0;
    this.frameTimer = 0;
    this.frameIntervalBase = FRAME_INTERVAL_BASE;
    this.isMoving = false;

    // IMPORTANT: mask built from Player1Up only
    this.maskFromUp = null; // {mask,w,h} or null
  }

  update(dt, input, world, camera, canvas, particleSystem){
    let vx=0, vy=0;
    if(input.isDown('w')||input.isDown('arrowup')) vy -= 1;
    if(input.isDown('s')||input.isDown('arrowdown')) vy += 1;
    if(input.isDown('a')||input.isDown('arrowleft')) vx -= 1;
    if(input.isDown('d')||input.isDown('arrowright')) vx += 1;
    const mag = Math.hypot(vx,vy);
    if(mag>0){ vx/=mag; vy/=mag; }

    // running
    const wantRun = input.isDown('shift');
    let canRun = false;
    if(wantRun){
      if(this.exhausted) canRun = false;
      else canRun = this.stamina > 0;
    } else canRun = false;
    this.running = canRun;

    const speed = this.baseSpeed * (this.running ? this.runMultiplier : 1);
    const nx = this.x + vx * speed * dt;
    const ny = this.y + vy * speed * dt;
    this.radius = Math.max(4, this.worldSize * 0.45);

    // collision using mask from Player1Up
    const collidesAt = (cx, cy) => this._collidesUsingUpMask(cx, cy, world);

    if(!collidesAt(nx, this.y)) this.x = nx;
    if(!collidesAt(this.x, ny)) this.y = ny;

    // stamina update
    this.isMoving = (vx !== 0 || vy !== 0);
    const willDrain = this.running && this.isMoving;
    if(willDrain){
      this.stamina -= STAMINA_DRAIN_PER_SEC * dt;
      if(this.stamina <= 0){
        this.stamina = 0;
        this.exhausted = true;
        this.running = false;
      }
    } else {
      this.stamina += STAMINA_RECOVER_PER_SEC * dt;
      if(this.stamina > STAMINA_MAX) this.stamina = STAMINA_MAX;
      if(this.exhausted && this.stamina >= STAMINA_MAX * 0.25) this.exhausted = false;
    }
    const sEl = document.getElementById('staminaVal'); if(sEl) sEl.textContent = Math.round(this.stamina);

    // facing from movement
    if(this.isMoving){
      if(Math.abs(vx) > Math.abs(vy)) this.direction = vx > 0 ? 'right' : 'left';
      else this.direction = vy > 0 ? 'down' : 'up';
      this.lastDirection = this.direction;
    } else {
      this.direction = this.lastDirection;
    }

    // animation timer (speed up while sprinting)
    const interval = this.running ? (this.frameIntervalBase / this.runMultiplier) : this.frameIntervalBase;
    if(this.isMoving){
      this.frameTimer += dt;
      while(this.frameTimer >= interval){
        this.frameTimer -= interval;
        this.frameIndex = 1 - this.frameIndex;
      }
    } else {
      this.frameIndex = 0;
      this.frameTimer = 0;
    }

    // particles
    if(this.isMoving){
      const spawnRate = this.running ? 0.020 : 0.055;
      this._stepAcc += dt;
      while(this._stepAcc >= spawnRate){
        this._stepAcc -= spawnRate;
        const spread = this.running ? 6 : 3;
        const backX = this.x - vx * (this.worldSize*0.5);
        const backY = this.y - vy * (this.worldSize*0.5);
        const ox = (Math.random()*2 - 1) * spread;
        const oy = (Math.random()*2 - 1) * spread * 0.6;
        const px = backX + ox;
        const py = backY + oy + this.worldSize*0.25;
        const speedMul = this.running ? 50 : 18;
        const pvx = (-vx * (10 + Math.random()*speedMul)) + (Math.random()*20 - 10);
        const pvy = (-vy * (6 + Math.random()*12)) + (Math.random()*6 - 3);

        const tx = Math.floor(this.x / TILE), ty = Math.floor(this.y / TILE);
        let color = '#c6b28a';
        const tileUnder = world.getTile(tx,ty);
        if(tileUnder >= TILE_GRASS_BASE && tileUnder < TILE_GRASS_BASE + GRASS_VARIANTS) {
          const gv = world.grassVariant[world.idx(tx,ty)] || 0;
          const grassPalette = ['#7cc85b','#6fb23a','#8bdc66','#5fb03a'];
          color = grassPalette[gv] || '#8bd26a';
        } else if(tileUnder === TILE_DIRT) color = '#9f6b3a';
        else if(tileUnder === TILE_WATER) color = '#6fc3ff';

        const life = this.running ? 0.35 + Math.random()*0.2 : 0.6 + Math.random()*0.4;
        particleSystem.spawn(px, py, pvx, pvy, life, color);
      }
    } else {
      this._stepAcc = Math.max(0, this._stepAcc - dt*2);
    }
  }

  draw(ctx){
    ctx.save();
    ctx.imageSmoothingEnabled = false;
    const w = this.worldSize, h = this.worldSize;

    if(!this.isMoving && this.idleImg && this.idleImg.complete){
      ctx.translate(this.x, this.y); ctx.drawImage(this.idleImg, -w/2, -h/2, w, h); ctx.restore(); return;
    }

    let img = null;
    if(this.direction === 'left'){
      const rightMap = this.animMap.right;
      img = rightMap ? (rightMap[this.frameIndex] || rightMap[0]) : null;
      if(img && img.complete){
        ctx.translate(this.x, this.y); ctx.scale(-1,1); ctx.drawImage(img, -w/2, -h/2, w, h); ctx.restore(); return;
      }
    } else {
      const map = (this.direction === 'right') ? this.animMap.right : (this.direction === 'down' ? this.animMap.down : this.animMap.up);
      img = map ? (map[this.frameIndex] || map[0]) : null;
      if(img && img.complete){
        ctx.translate(this.x, this.y); ctx.drawImage(img, -w/2, -h/2, w, h); ctx.restore(); return;
      }
    }

    ctx.translate(this.x, this.y); ctx.fillStyle='#ffd8a8'; ctx.fillRect(-this.worldSize/4, -this.worldSize/4, this.worldSize/2, this.worldSize/2); ctx.restore();
  }

  // Build mask from Player1Up image (call once after assets load)
  buildMaskFromPlayer1Up(img){
    this.maskFromUp = buildMaskFromImage(img);
    if(this.maskFromUp) console.log('Player collision mask built from Player1Up.png', this.maskFromUp.w + 'x' + this.maskFromUp.h);
  }

  // Use maskFromUp for pixel-perfect collision vs tiles (water) and trees.
  // If mask missing -> fallback to circle collision.
  _collidesUsingUpMask(cx, cy, world){
    if(!this.maskFromUp){
      // fallback
      const r = this.radius;
      const tx0 = Math.floor((cx - r) / TILE), tx1 = Math.floor((cx + r) / TILE);
      const ty0 = Math.floor((cy - r) / TILE), ty1 = Math.floor((cy + r + r) / TILE);
      for(let ty=ty0; ty<=ty1; ty++){
        for(let tx=tx0; tx<=tx1; tx++){
          if(!world.inBounds(tx,ty)) continue;
          const tile = world.getTile(tx,ty);
          if(tile === TILE_WATER){ if(circleRectIntersect(cx,cy,r, tx*TILE, ty*TILE, TILE, TILE)) return true; }
        }
      }
      for(const t of world.trees){
        const dx = t.cx - cx, dy = t.cy - cy; const maxDist = r + Math.sqrt(2)*(TREE_WORLD_SIZE/2);
        if(dx*dx + dy*dy > maxDist*maxDist) continue;
        if(circleVsTreeMask(cx, cy, r, t.cx, t.cy)) return true;
      }
      return false;
    }

    const pm = this.maskFromUp.mask, pw = this.maskFromUp.w, ph = this.maskFromUp.h;
    const half = this.worldSize / 2;

    // helper: does mask overlap rect [rectX,rectY,rectW,rectH] when mask is centered at (cx,cy) mapped to worldSize?
    const maskIntersectsRect = (rectX, rectY, rectW, rectH, cx_local, cy_local, worldSize) => {
      const left_world = cx_local - worldSize/2;
      const top_world = cy_local - worldSize/2;
      const pxPerWorld = pw / worldSize;
      const ix0 = Math.max(0, Math.floor((rectX - left_world) * pxPerWorld));
      const iy0 = Math.max(0, Math.floor((rectY - top_world) * pxPerWorld));
      const ix1 = Math.min(pw - 1, Math.ceil(((rectX + rectW) - left_world) * pxPerWorld) - 1);
      const iy1 = Math.min(ph - 1, Math.ceil(((rectY + rectH) - top_world) * pxPerWorld) - 1);
      if(ix1 < ix0 || iy1 < iy0) return false;
      for(let yy=iy0; yy<=iy1; yy++){
        for(let xx=ix0; xx<=ix1; xx++){
          if(pm[yy*pw + xx]) return true;
        }
      }
      return false;
    };

    // 1) water tiles
    const playerLeft = cx - half, playerTop = cy - half, playerRight = cx + half, playerBottom = cy + half;
    const tx0 = Math.floor(playerLeft / TILE), tx1 = Math.floor(playerRight / TILE);
    const ty0 = Math.floor(playerTop / TILE), ty1 = Math.floor(playerBottom / TILE);
    for(let ty=ty0; ty<=ty1; ty++){
      for(let tx=tx0; tx<=tx1; tx++){
        if(!world.inBounds(tx,ty)) continue;
        const tile = world.getTile(tx,ty);
        if(tile === TILE_WATER){
          const rectX = tx * TILE, rectY = ty * TILE;
          if(maskIntersectsRect(rectX, rectY, TILE, TILE, cx, cy, this.worldSize)) return true;
        }
      }
    }

    // 2) trees — compare maskFromUp against treeMask per-pixel within overlap region
    if(treeMask && treeImgW > 0){
      for(const t of world.trees){
        const treeLeft = t.cx - TREE_WORLD_SIZE/2, treeTop = t.cy - TREE_WORLD_SIZE/2;
        const treeRight = t.cx + TREE_WORLD_SIZE/2, treeBottom = t.cy + TREE_WORLD_SIZE/2;
        if(treeRight < playerLeft || treeLeft > playerRight || treeBottom < playerTop || treeTop > playerBottom) continue;

        const ox0 = Math.max(playerLeft, treeLeft);
        const oy0 = Math.max(playerTop, treeTop);
        const ox1 = Math.min(playerRight, treeRight);
        const oy1 = Math.min(playerBottom, treeBottom);
        if(ox1 <= ox0 || oy1 <= oy0) continue;

        const pxPerWorld_player = pw / this.worldSize;
        const p_ix0 = Math.max(0, Math.floor((ox0 - (cx - this.worldSize/2)) * pxPerWorld_player));
        const p_iy0 = Math.max(0, Math.floor((oy0 - (cy - this.worldSize/2)) * pxPerWorld_player));
        const p_ix1 = Math.min(pw-1, Math.ceil((ox1 - (cx - this.worldSize/2)) * pxPerWorld_player) - 1);
        const p_iy1 = Math.min(ph-1, Math.ceil((oy1 - (cy - this.worldSize/2)) * pxPerWorld_player) - 1);

        const pxPerWorld_tree = treeImgW / TREE_WORLD_SIZE;
        const t_ix0 = Math.max(0, Math.floor((ox0 - (t.cx - TREE_WORLD_SIZE/2)) * pxPerWorld_tree));
        const t_iy0 = Math.max(0, Math.floor((oy0 - (t.cy - TREE_WORLD_SIZE/2)) * pxPerWorld_tree));
        const t_ix1 = Math.min(treeImgW-1, Math.ceil((ox1 - (t.cx - TREE_WORLD_SIZE/2)) * pxPerWorld_tree) - 1);
        const t_iy1 = Math.min(treeImgH-1, Math.ceil((oy1 - (t.cy - TREE_WORLD_SIZE/2)) * pxPerWorld_tree) - 1);

        if(p_ix1 < p_ix0 || p_iy1 < p_iy0 || t_ix1 < t_ix0 || t_iy1 < t_iy0) continue;

        const p_w = p_ix1 - p_ix0 + 1;
        const p_h = p_iy1 - p_iy0 + 1;
        for(let py = 0; py < p_h; py++){
          for(let px = 0; px < p_w; px++){
            const pxx = p_ix0 + px;
            const pyy = p_iy0 + py;
            const txx = t_ix0 + px;
            const tyy = t_iy0 + py;
            if(pxx < 0 || pxx >= pw || pyy < 0 || pyy >= ph) continue;
            if(txx < 0 || txx >= treeImgW || tyy < 0 || tyy >= treeImgH) continue;
            if(pm[pyy*pw + pxx] && treeMask[tyy*treeImgW + txx]) return true;
          }
        }
      }
    }

    return false;
  }
}

// ========== COLLISION FALLBACK HELPERS ==========
function circleRectIntersect(cx,cy,r, rx,ry,rw,rh){ const closestX = Math.max(rx, Math.min(cx, rx+rw)); const closestY = Math.max(ry, Math.min(cy, ry+rh)); const dx = cx - closestX, dy = cy - closestY; return (dx*dx + dy*dy) <= r*r; }
function circleVsTreeMask(circleX, circleY, circleR, treeCenterX, treeCenterY){
  if(!treeMask || treeImgW === 0) return false;
  const left_world = treeCenterX - TREE_WORLD_SIZE/2;
  const top_world  = treeCenterY - TREE_WORLD_SIZE/2;
  const pxPerWorld = treeImgW / TREE_WORLD_SIZE;
  const bx0 = circleX - circleR, bx1 = circleX + circleR;
  const by0 = circleY - circleR, by1 = circleY + circleR;
  const ix0 = Math.max(0, Math.floor((bx0 - left_world) * pxPerWorld));
  const iy0 = Math.max(0, Math.floor((by0 - top_world) * pxPerWorld));
  const ix1 = Math.min(treeImgW - 1, Math.ceil((bx1 - left_world) * pxPerWorld) - 1);
  const iy1 = Math.min(treeImgH - 1, Math.ceil((by1 - top_world) * pxPerWorld) - 1);
  if(ix1 < ix0 || iy1 < iy0) return false;
  for(let py = iy0; py <= iy1; py++){
    for(let px = ix0; px <= ix1; px++){
      if(treeMask[py*treeImgW + px]){
        const pixelCenterWorldX = left_world + (px + 0.5) / pxPerWorld;
        const pixelCenterWorldY = top_world  + (py + 0.5) / pxPerWorld;
        const dx = pixelCenterWorldX - circleX;
        const dy = pixelCenterWorldY - circleY;
        if(dx*dx + dy*dy <= circleR*circleR) return true;
      }
    }
  }
  return false;
}

// ========== GLOBALS & LOADER ==========
let atlasSmall, world, particleSystem, player, camera, input;
let ROCK_BASE_WORLD_SIZE = TILE * 0.24;
let treeImg = null;
let rockImgs = [];
let imagesByPath = {};
let cloudImg = null; // <-- cloud image reference

function drawStaminaBar(){ const bar=document.getElementById('stamina'); if(!bar) return; const pct=player.stamina/STAMINA_MAX; const w=160,h=10,inner=Math.round(pct*w); const timeEl = document.getElementById('timeDisplay'); if(timeEl) timeEl.textContent = `Time: ${formatTimeOfDay(timeOfDay)}`; bar.innerHTML = `Stamina: <span id="staminaVal">${Math.round(player.stamina)}</span>\n    <div style="margin-top:6px;background:rgba(255,255,255,0.08);width:${w}px;height:${h}px;border-radius:6px;overflow:hidden">\n      <div style="width:${inner}px;height:${h}px;background:linear-gradient(90deg,#9be15d,#27ae60);"></div>\n    </div>`; }
function loopUISync(){ drawStaminaBar(); requestAnimationFrame(loopUISync); }

const assetPaths = [
  'Loading.png',
  'Tree.png',
  'Rock1.png','Rock2.png','Rock3.png',
  'Player1Down.png','Player2Down.png',
  'Player1Up.png','Player2Up.png',
  'Player1Right.png','Player2Right.png',
  'IdlePlayer.png',
  'Cloud.png' // <<< add the 16x16 cloud texture (place Cloud.png in repo)
];

function loadAssets(paths, onProgress, onComplete){
  const total = paths.length;
  let loaded = 0;
  const out = {};
  if(total === 0){ onComplete(out); return; }
  paths.forEach(p => {
    const img = new Image();
    img.onload = () => { loaded++; out[p] = img; onProgress(loaded, total); if(loaded === total) onComplete(out); };
    img.onerror = () => { console.warn('Failed to load', p); loaded++; out[p] = img; onProgress(loaded, total); if(loaded === total) onComplete(out); };
    img.src = p;
  });
}

const progressBarInner = document.getElementById('progressBarInner');
const progressText = document.getElementById('progressText');
const loadingOverlay = document.getElementById('loadingOverlay');

loadAssets(assetPaths, (loaded, total) => {
  const pct = Math.round(loaded / total * 100);
  progressBarInner.style.width = pct + '%';
  progressText.textContent = `Loading — ${pct}%`;
}, (loadedImages) => {
  imagesByPath = loadedImages;
  if(imagesByPath['Tree.png'] && imagesByPath['Tree.png'].complete){ treeImg = imagesByPath['Tree.png']; buildTreeMaskFromImage(treeImg); }
  rockImgs = [ imagesByPath['Rock1.png'], imagesByPath['Rock2.png'], imagesByPath['Rock3.png'] ];
  cloudImg = imagesByPath['Cloud.png'] || null; // cloud texture
  loadingOverlay.classList.add('hidden');
  setTimeout(startGame, 480);
});

// ========== DAY/NIGHT HELPERS ==========
function formatTimeOfDay(t){
  const h = Math.floor(t) % 24;
  const m = Math.floor((t - Math.floor(t)) * 60);
  return String(h).padStart(2,'0') + ':' + String(m).padStart(2,'0');
}

function initStars(seed){
  stars.length = 0;
  const rnd = makeSeededRandom(seed >>> 0);
  const count = 160;
  for(let i=0;i<count;i++){
    stars.push({ x: rnd(), y: rnd()*0.6, size: 0.5 + rnd()*1.6, alpha: 0.4 + rnd()*0.6, twinkle: rnd()*6 });
  }
}

// ========== CLOUD LAYER ==========
class CloudLayer {
  constructor(cloudImg, worldW, worldH, seed = 0){
    this.img = cloudImg; // 16x16
    this.worldW = worldW * TILE; // convert to world pixels
    this.worldH = worldH * TILE;
    this.seed = seed >>> 0;
    this.clouds = []; // {x,y,scale,alpha,drift}
    this.time = 0;
    this.offsetX = 0;
    this.offsetY = 0;
    this._rnd = makeSeededRandom(seed || 123456);
    this.generate();
  }

  generate(){
    this.clouds.length = 0;
    // spacing controls density. larger spacing -> fewer clouds
    const spacing = TILE * 3.6; // tile every ~4 world tiles
    const margin = Math.max(canvasW, canvasH) * 2;
    const startX = -margin;
    const startY = -margin;
    const endX = this.worldW + margin;
    const endY = this.worldH + margin;
    for(let y = startY; y < endY; y += spacing){
      for(let x = startX; x < endX; x += spacing){
        // jitter and variety
        const jx = (this._rnd() - 0.5) * spacing * 0.6;
        const jy = (this._rnd() - 0.5) * spacing * 0.4;
        const scale = 0.8 + this._rnd() * 1.6; // world-space scale for the small 16px sprite
        const alpha = 0.08 + this._rnd() * 0.22;
        const drift = (0.8 + this._rnd() * 1.4) * (0.5 + this._rnd()); // px/sec drift in world-space (modified by parallax)
        this.clouds.push({ x: x + jx, y: y + jy, scale, alpha, drift, phase: this._rnd()*Math.PI*2 });
      }
    }
  }

  update(dt){
    this.time += dt;
    // slow global drift
    this.offsetX += dt * 6;
    // wrap offsets to avoid large numbers
    if(Math.abs(this.offsetX) > 1e6) this.offsetX = 0;
  }

  // camera: Camera instance
  draw(ctx, camera){
    if(!this.img || !this.img.complete) return;
    // intensity: 0 when at CAMERA_DEFAULT, 1 at ZOOM_OUT_MIN (zoomed out)
    const t = clamp((CAMERA_DEFAULT - camera.scale) / (CAMERA_DEFAULT - ZOOM_OUT_MIN || 1e-6), 0, 1);
    // cloud visual parameters driven by t (zoom-out increases cloud presence)
    const alphaMul = lerp(0.0, 1.0, smoothstep(t));
    const globalScaleMul = lerp(1.0, 1.6, t); // clouds become a bit larger when zoomed out
    // parallax factor: smaller => clouds move less when camera moves (appear further)
    const parallax = lerp(0.70, 0.28, t);

    // transform so clouds are in world-space but with parallax
    const S = camera.scale * DPR * parallax;
    const tx = canvasW * DPR / 2 - camera.x * camera.scale * DPR * parallax;
    const ty = canvasH * DPR / 2 - camera.y * camera.scale * DPR * parallax;

    ctx.save();
    ctx.setTransform(S, 0, 0, S, tx, ty);
    ctx.imageSmoothingEnabled = false;
    // draw only visible clouds (in world coords)
    const invS = 1 / S;
    const leftWorld = -tx * invS - 64;
    const topWorld = -ty * invS - 64;
    const rightWorld = leftWorld + canvasW * DPR * invS + 128;
    const bottomWorld = topWorld + canvasH * DPR * invS + 128;

    const imgW = this.img.width, imgH = this.img.height;

    for(const c of this.clouds){
      // modest per-cloud movement (phase + global offset)
      const cx = c.x + Math.sin(this.time * 0.1 + c.phase) * 6 + this.offsetX * 0.06;
      const cy = c.y + Math.cos(this.time * 0.07 + c.phase) * 2;

      if(cx + imgW * c.scale * globalScaleMul < leftWorld || cx - imgW * c.scale * globalScaleMul > rightWorld) continue;
      if(cy + imgH * c.scale * globalScaleMul < topWorld || cy - imgH * c.scale * globalScaleMul > bottomWorld) continue;

      const worldScale = c.scale * globalScaleMul;
      ctx.globalAlpha = c.alpha * alphaMul;
      // draw a cluster of 4 sprites slightly offset to make clouds feel less tiled
      const s = imgW * worldScale;
      ctx.drawImage(this.img, cx - s * 0.5, cy - s * 0.5, s, s);
      ctx.drawImage(this.img, cx + s * 0.3, cy - s * 0.15, s * 0.9, s * 0.9);
      ctx.drawImage(this.img, cx - s * 0.45, cy + s * 0.25, s * 0.85, s * 0.85);
    }
    ctx.globalAlpha = 1;
    ctx.restore();
  }
}

// ========== GAME LOOP & RENDER ==========
let last = 0;
let cloudLayer = null;

function gameLoop(now){
  if(!last) last = now;
  const dt = Math.min((now-last)/1000, 1/15);
  last = now;

  // advance time
  timeOfDay = (timeOfDay + dt * (24 / DAY_LENGTH_SECONDS)) % 24;

  player.update(dt,input,world,camera,canvas, particleSystem);
  camera.update(dt,player.x,player.y);
  const mw = camera.screenToWorld(input.mouse.x, input.mouse.y);
  input.mouse.worldX = mw.x; input.mouse.worldY = mw.y;
  cloudLayer && cloudLayer.update(dt);
  render(dt);
  requestAnimationFrame(gameLoop);
}

function render(dt){
  // -- background sky (screen-space) --
  ctx.setTransform(1,0,0,1,0,0);
  ctx.clearRect(0,0, canvas.width, canvas.height);

  // simple day/night blend — day color then dark overlay
  const angle = (timeOfDay / 24) * Math.PI * 2 - Math.PI/2; // -PI/2 so sunrise at ~6:00
  const sunElev = Math.max(0, Math.sin(angle)); // 0..1 when sun above horizon
  const daylight = clamp(0.12 + sunElev * 0.88, 0.12, 1); // bias slightly brighter overall

  // base sky (day color)
  ctx.fillStyle = '#87CEEB';
  ctx.fillRect(0,0, canvas.width, canvas.height);

  // subtle horizon gradient for sunrise/sunset tint
  const g = ctx.createLinearGradient(0, canvas.height*0.15, 0, canvas.height);
  g.addColorStop(0, `rgba(255,180,120,${clamp((sunElev*1.2-0.08),0,1)})`);
  g.addColorStop(0.4, 'rgba(255,120,100,0)');
  g.addColorStop(1, 'rgba(0,0,0,0)');
  ctx.fillStyle = g;
  ctx.fillRect(0,0, canvas.width, canvas.height);

  // draw sun (behind world) — visible when above horizon
  const sunX = canvas.width * (timeOfDay / 24);
  const sunY = canvas.height * 0.18 + Math.sin(angle) * (canvas.height * 0.18);
  if(sunElev > 0.02){
    const r = 36 * DPR;
    const rg = ctx.createRadialGradient(sunX, sunY, 0, sunX, sunY, r*3);
    rg.addColorStop(0, 'rgba(255,240,160,0.95)');
    rg.addColorStop(0.4, 'rgba(255,200,100,0.18)');
    rg.addColorStop(1, 'rgba(255,180,80,0)');
    ctx.fillStyle = rg; ctx.beginPath(); ctx.arc(sunX, sunY, r*2.5,0,Math.PI*2); ctx.fill();
  }

  // --- draw clouds behind the world (gives a "far away" feel) ---
  // Option: draw clouds behind world: call cloudLayer.draw() now.
  if(cloudLayer) cloudLayer.draw(ctx, camera);

  // draw world and game-space stuff with camera transform
  const S = camera.scale * DPR;
  const tx = canvasW * DPR / 2 - camera.x * camera.scale * DPR;
  const ty = canvasH * DPR / 2 - camera.y * camera.scale * DPR;
  ctx.setTransform(S, 0, 0, S, tx, ty);
  ctx.imageSmoothingEnabled = false;

  world.draw(ctx, camera, canvas, atlasSmall, treeImg, TREE_WORLD_SIZE, rockImgs, ROCK_BASE_WORLD_SIZE);
  particleSystem.update(dt);
  particleSystem.draw(ctx);
  player.draw(ctx);

  // draw grid (debug)
  ctx.save(); ctx.globalAlpha = 0.02; ctx.lineWidth = 1 / S; ctx.strokeStyle = '#000';
  const left = Math.floor((camera.x - (canvasW/2)/camera.scale)/TILE) - 1;
  const right = Math.ceil((camera.x + (canvasW/2)/camera.scale)/TILE) + 1;
  const top = Math.floor((camera.y - (canvasH/2)/camera.scale)/TILE) -1;
  const bottom = Math.ceil((camera.y + (canvasH/2)/camera.scale)/TILE) +1;
  for(let x=left;x<=right;x++){ ctx.beginPath(); ctx.moveTo(x*TILE, top*TILE); ctx.lineTo(x*TILE, bottom*TILE); ctx.stroke(); }
  for(let y=top;y<=bottom;y++){ ctx.beginPath(); ctx.moveTo(left*TILE, y*TILE); ctx.lineTo(right*TILE, y*TILE); ctx.stroke(); }
  ctx.restore();

  // NOTE: you can also draw clouds on top of the world by calling cloudLayer.draw(ctx,camera) here instead.

  // overlay darkness (screen-space)
  ctx.setTransform(1,0,0,1,0,0);
  // make night less dark: cap maximum darkness to ~0.5 instead of near-black
  const nightAlpha = clamp(1 - daylight, 0, 0.5);
  // subtle blue-black tint
  ctx.fillStyle = `rgba(3,8,20,${nightAlpha})`;
  ctx.fillRect(0,0, canvas.width, canvas.height);

  // stars (only at night) — make them more subtle when night is brighter
  if(daylight < 0.45){
    const starAlphaMul = clamp((1 - daylight) * 0.9, 0, 1);
    ctx.globalCompositeOperation = 'lighter';
    for(let i=0;i<stars.length;i++){
      const s = stars[i];
      const x = Math.floor(s.x * canvas.width);
      const y = Math.floor(s.y * canvas.height);
      const a = s.alpha * starAlphaMul * (0.5 + 0.5 * Math.sin((timeOfDay + s.twinkle) * 5.0));
      ctx.globalAlpha = a;
      ctx.fillRect(x, y, Math.max(1, Math.round(s.size*DPR)), Math.max(1, Math.round(s.size*DPR)));
    }
    ctx.globalCompositeOperation = 'source-over';
    ctx.globalAlpha = 1;
  }

  // NOTE: per request, we do NOT draw a moon or any bright object on top of the scene — it should not be seeable at night.
}


// ========== START GAME ==========
function startGame(){
  atlasSmall = createPixelatedTileAtlas(8);
  world = new World(MAP_W, MAP_H);
  initStars(world.seed);
  const spawn = world.findSafeSpawn();
  particleSystem = new ParticleSystem(120);
  player = new Player(spawn.x, spawn.y);

  function imgOrNull(name){ return (imagesByPath[name] && imagesByPath[name].complete) ? imagesByPath[name] : null; }
  player.animMap.down[0] = imgOrNull('Player1Down.png');
  player.animMap.down[1] = imgOrNull('Player2Down.png');
  player.animMap.up[0] = imgOrNull('Player1Up.png');
  player.animMap.up[1] = imgOrNull('Player2Up.png');
  player.animMap.right[0] = imgOrNull('Player1Right.png');
  player.animMap.right[1] = imgOrNull('Player2Right.png');
  player.idleImg = imgOrNull('IdlePlayer.png');

  if(imagesByPath['Tree.png']) treeImg = imagesByPath['Tree.png'];
  rockImgs = [ imagesByPath['Rock1.png'], imagesByPath['Rock2.png'], imagesByPath['Rock3.png'] ];

  // set player size constant
  player.worldSize = PLAYER_WORLD_SIZE;
  player.radius = Math.max(4, player.worldSize * 0.45);

  // Build mask from Player1Up (this is the new requirement)
  if(player.animMap.up[0]) player.buildMaskFromPlayer1Up(player.animMap.up[0]);

  camera = new Camera(player.x, player.y, CAMERA_DEFAULT);
  input = new Input(canvas);

  // create cloud layer (uses Cloud.png)
  if(cloudImg && cloudImg.complete){
    cloudLayer = new CloudLayer(cloudImg, MAP_W, MAP_H, world.seed ^ 0xC0FFEE);
  } else {
    cloudLayer = null;
  }

  requestAnimationFrame(loopUISync);
  last = performance.now();
  requestAnimationFrame(gameLoop);
}

window.addEventListener('resize', ()=>{ resizeCanvas(); });

</script>
</body>
</html>
